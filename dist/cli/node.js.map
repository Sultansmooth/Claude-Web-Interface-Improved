{
  "version": 3,
  "sources": ["../../app.ts", "../../middleware/config.ts", "../../utils/fs.ts", "../../utils/os.ts", "../../history/pathUtils.ts", "../../node_modules/@logtape/logtape/src/filter.ts", "../../node_modules/@logtape/logtape/src/level.ts", "../../node_modules/@logtape/logtape/src/logger.ts", "../../node_modules/@logtape/logtape/src/util.node.ts", "../../node_modules/@logtape/logtape/src/formatter.ts", "../../node_modules/@logtape/logtape/src/sink.ts", "../../node_modules/@logtape/logtape/src/config.ts", "../../node_modules/@logtape/pretty/terminal.ts", "../../node_modules/@logtape/pretty/truncate.ts", "../../node_modules/@logtape/pretty/wcwidth.ts", "../../node_modules/@logtape/pretty/wordwrap.ts", "../../node_modules/@logtape/pretty/util.node.ts", "../../node_modules/@logtape/pretty/formatter.ts", "../../utils/logger.ts", "../../handlers/projects.ts", "../../history/parser.ts", "../../history/grouping.ts", "../../handlers/histories.ts", "../../history/timestampRestore.ts", "../../history/conversationLoader.ts", "../../handlers/conversations.ts", "../../handlers/chat.ts", "../../handlers/abort.ts", "../../runtime/node.ts", "../../cli/args.ts", "../../cli/version.ts", "../../cli/validation.ts", "../../cli/node.ts"],
  "sourcesContent": ["/**\n * Runtime-agnostic Hono application\n *\n * This module creates the Hono application with all routes and middleware,\n * but doesn't include runtime-specific code like CLI parsing or server startup.\n */\n\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport type { Runtime } from \"./runtime/types.ts\";\nimport {\n  type ConfigContext,\n  createConfigMiddleware,\n} from \"./middleware/config.ts\";\nimport { handleProjectsRequest } from \"./handlers/projects.ts\";\nimport { handleHistoriesRequest } from \"./handlers/histories.ts\";\nimport { handleConversationRequest } from \"./handlers/conversations.ts\";\nimport { handleChatRequest } from \"./handlers/chat.ts\";\nimport { handleAbortRequest } from \"./handlers/abort.ts\";\nimport { logger } from \"./utils/logger.ts\";\nimport { readBinaryFile } from \"./utils/fs.ts\";\n\nexport interface AppConfig {\n  debugMode: boolean;\n  staticPath: string;\n  cliPath: string; // Actual CLI script path detected by validateClaudeCli\n}\n\nexport function createApp(\n  runtime: Runtime,\n  config: AppConfig,\n): Hono<ConfigContext> {\n  const app = new Hono<ConfigContext>();\n\n  // Store AbortControllers for each request (shared with chat handler)\n  const requestAbortControllers = new Map<string, AbortController>();\n\n  // CORS middleware\n  app.use(\n    \"*\",\n    cors({\n      origin: \"*\",\n      allowMethods: [\"GET\", \"POST\", \"OPTIONS\"],\n      allowHeaders: [\"Content-Type\"],\n    }),\n  );\n\n  // Configuration middleware - makes app settings available to all handlers\n  app.use(\n    \"*\",\n    createConfigMiddleware({\n      debugMode: config.debugMode,\n      runtime,\n      cliPath: config.cliPath,\n    }),\n  );\n\n  // API routes\n  app.get(\"/api/projects\", (c) => handleProjectsRequest(c));\n\n  app.get(\"/api/projects/:encodedProjectName/histories\", (c) =>\n    handleHistoriesRequest(c),\n  );\n\n  app.get(\"/api/projects/:encodedProjectName/histories/:sessionId\", (c) =>\n    handleConversationRequest(c),\n  );\n\n  app.post(\"/api/abort/:requestId\", (c) =>\n    handleAbortRequest(c, requestAbortControllers),\n  );\n\n  app.post(\"/api/chat\", (c) => handleChatRequest(c, requestAbortControllers));\n\n  // Static file serving with SPA fallback\n  // Serve static assets (CSS, JS, images, etc.)\n  const serveStatic = runtime.createStaticFileMiddleware({\n    root: config.staticPath,\n  });\n  app.use(\"/assets/*\", serveStatic);\n\n  // SPA fallback - serve index.html for all unmatched routes (except API routes)\n  app.get(\"*\", async (c) => {\n    const path = c.req.path;\n\n    // Skip API routes\n    if (path.startsWith(\"/api/\")) {\n      return c.text(\"Not found\", 404);\n    }\n\n    try {\n      const indexPath = `${config.staticPath}/index.html`;\n      const indexFile = await readBinaryFile(indexPath);\n      return c.html(new TextDecoder().decode(indexFile));\n    } catch (error) {\n      logger.app.error(\"Error serving index.html: {error}\", { error });\n      return c.text(\"Internal server error\", 500);\n    }\n  });\n\n  return app;\n}\n", "import { createMiddleware } from \"hono/factory\";\nimport type { AppConfig } from \"../types.ts\";\n\n/**\n * Creates configuration middleware that makes app-wide settings available to all handlers\n * via context variables. This eliminates the need to pass configuration parameters\n * to individual handler functions.\n *\n * @param options Configuration options\n * @returns Hono middleware function\n */\nexport function createConfigMiddleware(options: AppConfig) {\n  return createMiddleware<{\n    Variables: {\n      config: AppConfig;\n    };\n  }>(async (c, next) => {\n    // Set configuration in context for access by handlers\n    c.set(\"config\", options);\n\n    await next();\n  });\n}\n\n/**\n * Type helper to ensure handlers can access the config variable\n * This can be used to extend the context type in handlers if needed\n */\nexport type ConfigContext = {\n  Variables: {\n    config: AppConfig;\n  };\n};\n", "/**\n * Shared file system utilities using Node.js fs module\n *\n * Provides cross-platform file system operations that work in both\n * Deno and Node.js environments using the standard Node.js fs API.\n */\n\nimport { promises as fs } from \"node:fs\";\nimport { constants as fsConstants } from \"node:fs\";\nimport { tmpdir } from \"node:os\";\nimport { join } from \"node:path\";\n\n/**\n * File system information\n */\nexport interface FileStats {\n  isFile: boolean;\n  isDirectory: boolean;\n  isSymlink: boolean;\n  size: number;\n  mtime: Date | null;\n}\n\n/**\n * Directory entry information\n */\nexport interface DirectoryEntry {\n  name: string;\n  isFile: boolean;\n  isDirectory: boolean;\n  isSymlink: boolean;\n}\n\n/**\n * Read text file content\n */\nexport async function readTextFile(path: string): Promise<string> {\n  return await fs.readFile(path, \"utf8\");\n}\n\n/**\n * Read binary file content\n */\nexport async function readBinaryFile(path: string): Promise<Uint8Array> {\n  const buffer = await fs.readFile(path);\n  return new Uint8Array(buffer);\n}\n\n/**\n * Write text content to file\n */\nexport async function writeTextFile(\n  path: string,\n  content: string,\n  options?: { mode?: number },\n): Promise<void> {\n  await fs.writeFile(path, content, \"utf8\");\n  if (options?.mode !== undefined) {\n    await fs.chmod(path, options.mode);\n  }\n}\n\n/**\n * Check if file or directory exists\n */\nexport async function exists(path: string): Promise<boolean> {\n  try {\n    await fs.access(path, fsConstants.F_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get file/directory statistics\n */\nexport async function stat(path: string): Promise<FileStats> {\n  const stats = await fs.stat(path);\n  return {\n    isFile: stats.isFile(),\n    isDirectory: stats.isDirectory(),\n    isSymlink: stats.isSymbolicLink(),\n    size: stats.size,\n    mtime: stats.mtime,\n  };\n}\n\n/**\n * Read directory entries\n */\nexport async function* readDir(path: string): AsyncIterable<DirectoryEntry> {\n  const entries = await fs.readdir(path, { withFileTypes: true });\n  for (const entry of entries) {\n    yield {\n      name: entry.name,\n      isFile: entry.isFile(),\n      isDirectory: entry.isDirectory(),\n      isSymlink: entry.isSymbolicLink(),\n    };\n  }\n}\n\n/**\n * Execute callback with a temporary directory that gets cleaned up\n */\nexport async function withTempDir<T>(\n  callback: (tempDir: string) => Promise<T>,\n): Promise<T> {\n  const tempDir = await fs.mkdtemp(join(tmpdir(), \"claude-code-webui-temp-\"));\n  try {\n    return await callback(tempDir);\n  } finally {\n    try {\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } catch {\n      // Silently ignore cleanup errors - temp dir will be cleaned up by OS eventually\n    }\n  }\n}\n", "/**\n * Shared OS utilities using Node.js os and process modules\n *\n * Provides cross-platform OS and process operations that work in both\n * Deno and Node.js environments using the standard Node.js APIs.\n */\n\nimport { homedir } from \"node:os\";\nimport process from \"node:process\";\n\n/**\n * Get environment variable\n */\nexport function getEnv(key: string): string | undefined {\n  return process.env[key];\n}\n\n/**\n * Get command line arguments (excluding node/deno and script path)\n */\nexport function getArgs(): string[] {\n  // process.argv.slice(2) works correctly in both Node.js and Deno (via node:process)\n  // Node.js: ['node', 'script.js', ...args] -> [...args]\n  // Deno: ['deno', 'run', 'script.ts', ...args] -> [...args] (when using node:process)\n  return process.argv.slice(2);\n}\n\n/**\n * Get platform identifier\n */\nexport function getPlatform(): \"windows\" | \"darwin\" | \"linux\" {\n  switch (process.platform) {\n    case \"win32\":\n      return \"windows\";\n    case \"darwin\":\n      return \"darwin\";\n    case \"linux\":\n      return \"linux\";\n    default:\n      // Default to linux for unknown platforms\n      return \"linux\";\n  }\n}\n\n/**\n * Get home directory path\n */\nexport function getHomeDir(): string | undefined {\n  try {\n    return homedir();\n  } catch {\n    // Fallback to undefined if os.homedir() fails\n    return undefined;\n  }\n}\n\n/**\n * Exit the process with given code\n */\nexport function exit(code: number): never {\n  process.exit(code);\n}\n", "/**\n * Path utilities for conversation history functionality\n * Handles conversion between project paths and Claude history directory names\n */\n\nimport { readDir } from \"../utils/fs.ts\";\nimport { getHomeDir } from \"../utils/os.ts\";\n\n/**\n * Get the encoded directory name for a project path by checking what actually exists\n * Example: \"/Users/sugyan/tmp/\" \u2192 \"-Users-sugyan-tmp\"\n */\nexport async function getEncodedProjectName(\n  projectPath: string,\n): Promise<string | null> {\n  const homeDir = getHomeDir();\n  if (!homeDir) {\n    return null;\n  }\n\n  const projectsDir = `${homeDir}/.claude/projects`;\n\n  try {\n    // Read all directories in .claude/projects\n    const entries = [];\n    for await (const entry of readDir(projectsDir)) {\n      if (entry.isDirectory) {\n        entries.push(entry.name);\n      }\n    }\n\n    // Convert project path to expected encoded format for comparison\n    const normalizedPath = projectPath.replace(/\\/$/, \"\");\n    // Claude converts '/', '\\', ':', '.', and '_' to '-'\n    const expectedEncoded = normalizedPath.replace(/[/\\\\:._]/g, \"-\");\n\n    // Find exact match - if not found, return null\n    if (entries.includes(expectedEncoded)) {\n      return expectedEncoded;\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Validate that an encoded project name is safe\n */\nexport function validateEncodedProjectName(encodedName: string): boolean {\n  // Should not be empty\n  if (!encodedName) {\n    return false;\n  }\n\n  // Should not contain dangerous characters for directory names\n  // deno-lint-ignore no-control-regex\n  const dangerousChars = /[<>:\"|?*\\x00-\\x1f\\/\\\\]/;\n  if (dangerousChars.test(encodedName)) {\n    return false;\n  }\n\n  return true;\n}\n", "import type { LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\n\n/**\n * A filter is a function that accepts a log record and returns `true` if the\n * record should be passed to the sink.\n *\n * @param record The log record to filter.\n * @returns `true` if the record should be passed to the sink.\n */\nexport type Filter = (record: LogRecord) => boolean;\n\n/**\n * A filter-like value is either a {@link Filter} or a {@link LogLevel}.\n * `null` is also allowed to represent a filter that rejects all records.\n */\nexport type FilterLike = Filter | LogLevel | null;\n\n/**\n * Converts a {@link FilterLike} value to an actual {@link Filter}.\n *\n * @param filter The filter-like value to convert.\n * @returns The actual filter.\n */\nexport function toFilter(filter: FilterLike): Filter {\n  if (typeof filter === \"function\") return filter;\n  return getLevelFilter(filter);\n}\n\n/**\n * Returns a filter that accepts log records with the specified level.\n *\n * @param level The level to filter by.  If `null`, the filter will reject all\n *              records.\n * @returns The filter.\n */\nexport function getLevelFilter(level: LogLevel | null): Filter {\n  if (level == null) return () => false;\n  if (level === \"fatal\") {\n    return (record: LogRecord) => record.level === \"fatal\";\n  } else if (level === \"error\") {\n    return (record: LogRecord) =>\n      record.level === \"fatal\" || record.level === \"error\";\n  } else if (level === \"warning\") {\n    return (record: LogRecord) =>\n      record.level === \"fatal\" ||\n      record.level === \"error\" ||\n      record.level === \"warning\";\n  } else if (level === \"info\") {\n    return (record: LogRecord) =>\n      record.level === \"fatal\" ||\n      record.level === \"error\" ||\n      record.level === \"warning\" ||\n      record.level === \"info\";\n  } else if (level === \"debug\") {\n    return (record: LogRecord) =>\n      record.level === \"fatal\" ||\n      record.level === \"error\" ||\n      record.level === \"warning\" ||\n      record.level === \"info\" ||\n      record.level === \"debug\";\n  } else if (level === \"trace\") return () => true;\n  throw new TypeError(`Invalid log level: ${level}.`);\n}\n", "const logLevels = [\n  \"trace\",\n  \"debug\",\n  \"info\",\n  \"warning\",\n  \"error\",\n  \"fatal\",\n] as const;\n\n/**\n * The severity level of a {@link LogRecord}.\n */\nexport type LogLevel = typeof logLevels[number];\n\n/**\n * Lists all available log levels with the order of their severity.\n * The `\"trace\"` level goes first, and the `\"fatal\"` level goes last.\n * @returns A new copy of the array of log levels.\n * @since 1.0.0\n */\nexport function getLogLevels(): readonly LogLevel[] {\n  return [...logLevels];\n}\n\n/**\n * Parses a log level from a string.\n *\n * @param level The log level as a string.  This is case-insensitive.\n * @returns The log level.\n * @throws {TypeError} If the log level is invalid.\n */\nexport function parseLogLevel(level: string): LogLevel {\n  level = level.toLowerCase();\n  switch (level) {\n    case \"trace\":\n    case \"debug\":\n    case \"info\":\n    case \"warning\":\n    case \"error\":\n    case \"fatal\":\n      return level;\n    default:\n      throw new TypeError(`Invalid log level: ${level}.`);\n  }\n}\n\n/**\n * Checks if a string is a valid log level.  This function can be used as\n * as a type guard to narrow the type of a string to a {@link LogLevel}.\n *\n * @param level The log level as a string.  This is case-sensitive.\n * @returns `true` if the string is a valid log level.\n */\nexport function isLogLevel(level: string): level is LogLevel {\n  switch (level) {\n    case \"trace\":\n    case \"debug\":\n    case \"info\":\n    case \"warning\":\n    case \"error\":\n    case \"fatal\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Compares two log levels.\n * @param a The first log level.\n * @param b The second log level.\n * @returns A negative number if `a` is less than `b`, a positive number if `a`\n *          is greater than `b`, or zero if they are equal.\n * @since 0.8.0\n */\nexport function compareLogLevel(a: LogLevel, b: LogLevel): number {\n  const aIndex = logLevels.indexOf(a);\n  if (aIndex < 0) {\n    throw new TypeError(`Invalid log level: ${JSON.stringify(a)}.`);\n  }\n  const bIndex = logLevels.indexOf(b);\n  if (bIndex < 0) {\n    throw new TypeError(`Invalid log level: ${JSON.stringify(b)}.`);\n  }\n  return aIndex - bIndex;\n}\n", "import type { ContextLocalStorage } from \"./context.ts\";\nimport type { Filter } from \"./filter.ts\";\nimport { compareLogLevel, type LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\nimport type { Sink } from \"./sink.ts\";\n\n/**\n * A logger interface.  It provides methods to log messages at different\n * severity levels.\n *\n * ```typescript\n * const logger = getLogger(\"category\");\n * logger.trace `A trace message with ${value}`\n * logger.debug `A debug message with ${value}.`;\n * logger.info `An info message with ${value}.`;\n * logger.warn `A warning message with ${value}.`;\n * logger.error `An error message with ${value}.`;\n * logger.fatal `A fatal error message with ${value}.`;\n * ```\n */\nexport interface Logger {\n  /**\n   * The category of the logger.  It is an array of strings.\n   */\n  readonly category: readonly string[];\n\n  /**\n   * The logger with the supercategory of the current logger.  If the current\n   * logger is the root logger, this is `null`.\n   */\n  readonly parent: Logger | null;\n\n  /**\n   * Get a child logger with the given subcategory.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = logger.getChild(\"sub-category\");\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = getLogger([\"category\", \"sub-category\"]);\n   * ```\n   *\n   * @param subcategory The subcategory.\n   * @returns The child logger.\n   */\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger;\n\n  /**\n   * Get a logger with contextual properties.  This is useful for\n   * log multiple messages with the shared set of properties.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const ctx = logger.with({ foo: 123, bar: \"abc\" });\n   * ctx.info(\"A message with {foo} and {bar}.\");\n   * ctx.warn(\"Another message with {foo}, {bar}, and {baz}.\", { baz: true });\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * logger.info(\"A message with {foo} and {bar}.\", { foo: 123, bar: \"abc\" });\n   * logger.warn(\n   *   \"Another message with {foo}, {bar}, and {baz}.\",\n   *   { foo: 123, bar: \"abc\", baz: true },\n   * );\n   * ```\n   *\n   * @param properties\n   * @returns\n   * @since 0.5.0\n   */\n  with(properties: Record<string, unknown>): Logger;\n\n  /**\n   * Log a trace message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.trace `A trace message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  trace(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a trace message with properties.\n   *\n   * ```typescript\n   * logger.trace('A trace message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.trace(\n   *   'A trace message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  trace(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a trace values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.trace({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.trace('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.trace('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  trace(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a trace message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.trace(l => l`A trace message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  trace(callback: LogCallback): void;\n\n  /**\n   * Log a debug message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.debug `A debug message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  debug(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a debug message with properties.\n   *\n   * ```typescript\n   * logger.debug('A debug message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.debug(\n   *   'A debug message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  debug(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a debug values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.debug({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.debug('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.debug('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  debug(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a debug message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.debug(l => l`A debug message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  debug(callback: LogCallback): void;\n\n  /**\n   * Log an informational message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.info `An info message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  info(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an informational message with properties.\n   *\n   * ```typescript\n   * logger.info('An info message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.info(\n   *   'An info message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  info(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an informational values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.info({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.info('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.info('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  info(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an informational message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.info(l => l`An info message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  info(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warn `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  warn(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warn('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warn(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  warn(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warn({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warn('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warn('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  warn(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warn(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  warn(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warning `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  warning(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warning('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warning(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  warning(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warning({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warning('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warning('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  warning(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warning(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  warning(callback: LogCallback): void;\n\n  /**\n   * Log an error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.error `An error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  error(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an error message with properties.\n   *\n   * ```typescript\n   * logger.warn('An error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.error(\n   *   'An error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  error(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.error({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.error('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.error('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  error(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.error(l => l`An error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  error(callback: LogCallback): void;\n\n  /**\n   * Log a fatal error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.fatal `A fatal error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  fatal(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a fatal error message with properties.\n   *\n   * ```typescript\n   * logger.warn('A fatal error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.fatal(\n   *   'A fatal error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  fatal(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a fatal error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.fatal({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.fatal('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.fatal('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  fatal(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a fatal error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.fatal(l => l`A fatal error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  fatal(callback: LogCallback): void;\n\n  /**\n   * Emits a log record with custom fields while using this logger's\n   * category.\n   *\n   * This is a low-level API for integration scenarios where you need full\n   * control over the log record, particularly for preserving timestamps\n   * from external systems.\n   *\n   * ```typescript\n   * const logger = getLogger([\"my-app\", \"integration\"]);\n   *\n   * // Emit a log with a custom timestamp\n   * logger.emit({\n   *   timestamp: kafkaLog.originalTimestamp,\n   *   level: \"info\",\n   *   message: [kafkaLog.message],\n   *   rawMessage: kafkaLog.message,\n   *   properties: {\n   *     source: \"kafka\",\n   *     partition: kafkaLog.partition,\n   *     offset: kafkaLog.offset,\n   *   },\n   * });\n   * ```\n   *\n   * @param record Log record without category field (category comes from\n   *               the logger instance)\n   * @since 1.1.0\n   */\n  emit(record: Omit<LogRecord, \"category\">): void;\n}\n\n/**\n * A logging callback function.  It is used to defer the computation of a\n * message template until it is actually logged.\n * @param prefix The message template prefix.\n * @returns The rendered message array.\n */\nexport type LogCallback = (prefix: LogTemplatePrefix) => unknown[];\n\n/**\n * A logging template prefix function.  It is used to log a message in\n * a {@link LogCallback} function.\n * @param message The message template strings array.\n * @param values The message template values.\n * @returns The rendered message array.\n */\nexport type LogTemplatePrefix = (\n  message: TemplateStringsArray,\n  ...values: unknown[]\n) => unknown[];\n\n/**\n * A function type for logging methods in the {@link Logger} interface.\n * @since 1.0.0\n */\nexport interface LogMethod {\n  /**\n   * Log a message with the given level using a template string.\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  (\n    message: TemplateStringsArray,\n    ...values: readonly unknown[]\n  ): void;\n\n  /**\n   * Log a message with the given level with properties.\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  (\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a message with the given level with no message.\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   */\n  (properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a message with the given level.\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  (callback: LogCallback): void;\n}\n\n/**\n * Get a logger with the given category.\n *\n * ```typescript\n * const logger = getLogger([\"my-app\"]);\n * ```\n *\n * @param category The category of the logger.  It can be a string or an array\n *                 of strings.  If it is a string, it is equivalent to an array\n *                 with a single element.\n * @returns The logger.\n */\nexport function getLogger(category: string | readonly string[] = []): Logger {\n  return LoggerImpl.getLogger(category);\n}\n\n/**\n * The symbol for the global root logger.\n */\nconst globalRootLoggerSymbol = Symbol.for(\"logtape.rootLogger\");\n\n/**\n * The global root logger registry.\n */\ninterface GlobalRootLoggerRegistry {\n  [globalRootLoggerSymbol]?: LoggerImpl;\n}\n\n/**\n * A logger implementation.  Do not use this directly; use {@link getLogger}\n * instead.  This class is exported for testing purposes.\n */\nexport class LoggerImpl implements Logger {\n  readonly parent: LoggerImpl | null;\n  readonly children: Record<string, LoggerImpl | WeakRef<LoggerImpl>>;\n  readonly category: readonly string[];\n  readonly sinks: Sink[];\n  parentSinks: \"inherit\" | \"override\" = \"inherit\";\n  readonly filters: Filter[];\n  lowestLevel: LogLevel | null = \"trace\";\n  contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;\n\n  static getLogger(category: string | readonly string[] = []): LoggerImpl {\n    let rootLogger: LoggerImpl | null = globalRootLoggerSymbol in globalThis\n      ? ((globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] ??\n        null)\n      : null;\n    if (rootLogger == null) {\n      rootLogger = new LoggerImpl(null, []);\n      (globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] =\n        rootLogger;\n    }\n    if (typeof category === \"string\") return rootLogger.getChild(category);\n    if (category.length === 0) return rootLogger;\n    return rootLogger.getChild(category as readonly [string, ...string[]]);\n  }\n\n  private constructor(parent: LoggerImpl | null, category: readonly string[]) {\n    this.parent = parent;\n    this.children = {};\n    this.category = category;\n    this.sinks = [];\n    this.filters = [];\n  }\n\n  getChild(\n    subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])],\n  ): LoggerImpl {\n    const name = typeof subcategory === \"string\" ? subcategory : subcategory[0];\n    const childRef = this.children[name];\n    let child: LoggerImpl | undefined = childRef instanceof LoggerImpl\n      ? childRef\n      : childRef?.deref();\n    if (child == null) {\n      child = new LoggerImpl(this, [...this.category, name]);\n      this.children[name] = \"WeakRef\" in globalThis\n        ? new WeakRef(child)\n        : child;\n    }\n    if (typeof subcategory === \"string\" || subcategory.length === 1) {\n      return child;\n    }\n    return child.getChild(\n      subcategory.slice(1) as [string, ...(readonly string[])],\n    );\n  }\n\n  /**\n   * Reset the logger.  This removes all sinks and filters from the logger.\n   */\n  reset(): void {\n    while (this.sinks.length > 0) this.sinks.shift();\n    this.parentSinks = \"inherit\";\n    while (this.filters.length > 0) this.filters.shift();\n    this.lowestLevel = \"trace\";\n  }\n\n  /**\n   * Reset the logger and all its descendants.  This removes all sinks and\n   * filters from the logger and all its descendants.\n   */\n  resetDescendants(): void {\n    for (const child of Object.values(this.children)) {\n      const logger = child instanceof LoggerImpl ? child : child.deref();\n      if (logger != null) logger.resetDescendants();\n    }\n    this.reset();\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this, { ...properties });\n  }\n\n  filter(record: LogRecord): boolean {\n    for (const filter of this.filters) {\n      if (!filter(record)) return false;\n    }\n    if (this.filters.length < 1) return this.parent?.filter(record) ?? true;\n    return true;\n  }\n\n  *getSinks(level: LogLevel): Iterable<Sink> {\n    if (\n      this.lowestLevel === null || compareLogLevel(level, this.lowestLevel) < 0\n    ) {\n      return;\n    }\n    if (this.parent != null && this.parentSinks === \"inherit\") {\n      for (const sink of this.parent.getSinks(level)) yield sink;\n    }\n    for (const sink of this.sinks) yield sink;\n  }\n\n  emit(record: Omit<LogRecord, \"category\">): void;\n  emit(record: LogRecord, bypassSinks?: Set<Sink>): void;\n  emit(\n    record: Omit<LogRecord, \"category\"> | LogRecord,\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const fullRecord: LogRecord = \"category\" in record\n      ? record as LogRecord\n      : { ...record, category: this.category };\n\n    if (\n      this.lowestLevel === null ||\n      compareLogLevel(fullRecord.level, this.lowestLevel) < 0 ||\n      !this.filter(fullRecord)\n    ) {\n      return;\n    }\n    for (const sink of this.getSinks(fullRecord.level)) {\n      if (bypassSinks?.has(sink)) continue;\n      try {\n        sink(fullRecord);\n      } catch (error) {\n        const bypassSinks2 = new Set(bypassSinks);\n        bypassSinks2.add(sink);\n        metaLogger.log(\n          \"fatal\",\n          \"Failed to emit a log record to sink {sink}: {error}\",\n          { sink, error, record: fullRecord },\n          bypassSinks2,\n        );\n      }\n    }\n  }\n\n  log(\n    level: LogLevel,\n    rawMessage: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    let cachedProps: Record<string, unknown> | undefined = undefined;\n    const record: LogRecord = typeof properties === \"function\"\n      ? {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        get message() {\n          return parseMessageTemplate(rawMessage, this.properties);\n        },\n        rawMessage,\n        get properties() {\n          if (cachedProps == null) {\n            cachedProps = {\n              ...implicitContext,\n              ...properties(),\n            };\n          }\n          return cachedProps;\n        },\n      }\n      : {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        message: parseMessageTemplate(rawMessage, {\n          ...implicitContext,\n          ...properties,\n        }),\n        rawMessage,\n        properties: { ...implicitContext, ...properties },\n      };\n    this.emit(record, bypassSinks);\n  }\n\n  logLazily(\n    level: LogLevel,\n    callback: LogCallback,\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    let rawMessage: TemplateStringsArray | undefined = undefined;\n    let msg: unknown[] | undefined = undefined;\n    function realizeMessage(): [unknown[], TemplateStringsArray] {\n      if (msg == null || rawMessage == null) {\n        msg = callback((tpl, ...values) => {\n          rawMessage = tpl;\n          return renderMessage(tpl, values);\n        });\n        if (rawMessage == null) throw new TypeError(\"No log record was made.\");\n      }\n      return [msg, rawMessage];\n    }\n    this.emit({\n      category: this.category,\n      level,\n      get message() {\n        return realizeMessage()[0];\n      },\n      get rawMessage() {\n        return realizeMessage()[1];\n      },\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    this.emit({\n      category: this.category,\n      level,\n      message: renderMessage(messageTemplate, values),\n      rawMessage: messageTemplate,\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * A logger implementation with contextual properties.  Do not use this\n * directly; use {@link Logger.with} instead.  This class is exported\n * for testing purposes.\n */\nexport class LoggerCtx implements Logger {\n  logger: LoggerImpl;\n  properties: Record<string, unknown>;\n\n  constructor(logger: LoggerImpl, properties: Record<string, unknown>) {\n    this.logger = logger;\n    this.properties = properties;\n  }\n\n  get category(): readonly string[] {\n    return this.logger.category;\n  }\n\n  get parent(): Logger | null {\n    return this.logger.parent;\n  }\n\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger {\n    return this.logger.getChild(subcategory).with(this.properties);\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this.logger, { ...this.properties, ...properties });\n  }\n\n  log(\n    level: LogLevel,\n    message: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    this.logger.log(\n      level,\n      message,\n      typeof properties === \"function\"\n        ? () => ({\n          ...this.properties,\n          ...properties(),\n        })\n        : { ...this.properties, ...properties },\n      bypassSinks,\n    );\n  }\n\n  logLazily(level: LogLevel, callback: LogCallback): void {\n    this.logger.logLazily(level, callback, this.properties);\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n  ): void {\n    this.logger.logTemplate(level, messageTemplate, values, this.properties);\n  }\n\n  emit(record: Omit<LogRecord, \"category\">): void {\n    const recordWithContext = {\n      ...record,\n      properties: { ...this.properties, ...record.properties },\n    };\n    this.logger.emit(recordWithContext);\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * The meta logger.  It is a logger with the category `[\"logtape\", \"meta\"]`.\n */\nconst metaLogger = LoggerImpl.getLogger([\"logtape\", \"meta\"]);\n\n/**\n * Parse a message template into a message template array and a values array.\n * @param template The message template.\n * @param properties The values to replace placeholders with.\n * @returns The message template array and the values array.\n */\nexport function parseMessageTemplate(\n  template: string,\n  properties: Record<string, unknown>,\n): readonly unknown[] {\n  const length = template.length;\n  if (length === 0) return [\"\"];\n\n  // Fast path: no placeholders\n  if (!template.includes(\"{\")) return [template];\n\n  const message: unknown[] = [];\n  let startIndex = 0;\n\n  for (let i = 0; i < length; i++) {\n    const char = template[i];\n\n    if (char === \"{\") {\n      const nextChar = i + 1 < length ? template[i + 1] : \"\";\n\n      if (nextChar === \"{\") {\n        // Escaped { character - skip and continue\n        i++; // Skip the next {\n        continue;\n      }\n\n      // Find the closing }\n      const closeIndex = template.indexOf(\"}\", i + 1);\n      if (closeIndex === -1) {\n        // No closing } found, treat as literal text\n        continue;\n      }\n\n      // Add text before placeholder\n      const beforeText = template.slice(startIndex, i);\n      message.push(beforeText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n      // Extract and process placeholder key\n      const key = template.slice(i + 1, closeIndex);\n\n      // Resolve property value\n      let prop: unknown;\n\n      // Check for wildcard patterns\n      const trimmedKey = key.trim();\n      if (trimmedKey === \"*\") {\n        // This is a wildcard pattern\n        prop = key in properties\n          ? properties[key]\n          : \"*\" in properties\n          ? properties[\"*\"]\n          : properties;\n      } else {\n        // Regular property lookup with possible whitespace handling\n        if (key !== trimmedKey) {\n          // Key has leading/trailing whitespace\n          prop = key in properties ? properties[key] : properties[trimmedKey];\n        } else {\n          // Key has no leading/trailing whitespace\n          prop = properties[key];\n        }\n      }\n\n      message.push(prop);\n      i = closeIndex; // Move to the }\n      startIndex = i + 1;\n    } else if (char === \"}\" && i + 1 < length && template[i + 1] === \"}\") {\n      // Escaped } character - skip\n      i++; // Skip the next }\n    }\n  }\n\n  // Add remaining text\n  const remainingText = template.slice(startIndex);\n  message.push(remainingText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n  return message;\n}\n\n/**\n * Render a message template with values.\n * @param template The message template.\n * @param values The message template values.\n * @returns The message template values interleaved between the substitution\n *          values.\n */\nexport function renderMessage(\n  template: TemplateStringsArray,\n  values: readonly unknown[],\n): unknown[] {\n  const args = [];\n  for (let i = 0; i < template.length; i++) {\n    args.push(template[i]);\n    if (i < values.length) args.push(values[i]);\n  }\n  return args;\n}\n", "import util from \"node:util\";\n\nexport interface InspectOptions {\n  colors?: boolean;\n  depth?: number | null;\n  compact?: boolean;\n  [key: string]: unknown;\n}\n\nexport function inspect(obj: unknown, options?: InspectOptions): string {\n  return util.inspect(obj, options);\n}\n", "import * as util from \"#util\";\nimport type { LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\n\n/**\n * A text formatter is a function that accepts a log record and returns\n * a string.\n *\n * @param record The log record to format.\n * @returns The formatted log record.\n */\nexport type TextFormatter = (record: LogRecord) => string;\n\n/**\n * The severity level abbreviations.\n */\nconst levelAbbreviations: Record<LogLevel, string> = {\n  \"trace\": \"TRC\",\n  \"debug\": \"DBG\",\n  \"info\": \"INF\",\n  \"warning\": \"WRN\",\n  \"error\": \"ERR\",\n  \"fatal\": \"FTL\",\n};\n\n/**\n * A platform-specific inspect function.  In Deno, this is {@link Deno.inspect},\n * and in Node.js/Bun it is `util.inspect()`.  If neither is available, it\n * falls back to {@link JSON.stringify}.\n *\n * @param value The value to inspect.\n * @param options The options for inspecting the value.\n *                If `colors` is `true`, the output will be ANSI-colored.\n * @returns The string representation of the value.\n */\nconst inspect: (value: unknown, options?: { colors?: boolean }) => string =\n  // @ts-ignore: Browser detection\n  // dnt-shim-ignore\n  typeof document !== \"undefined\" ||\n    // @ts-ignore: React Native detection\n    // dnt-shim-ignore\n    typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\"\n    ? (v) => JSON.stringify(v)\n    // @ts-ignore: Deno global\n    // dnt-shim-ignore\n    : \"Deno\" in globalThis && \"inspect\" in globalThis.Deno &&\n        // @ts-ignore: Deno global\n        // dnt-shim-ignore\n        typeof globalThis.Deno.inspect === \"function\"\n    ? (v, opts) =>\n      // @ts-ignore: Deno global\n      // dnt-shim-ignore\n      globalThis.Deno.inspect(v, {\n        strAbbreviateSize: Infinity,\n        iterableLimit: Infinity,\n        ...opts,\n      })\n    // @ts-ignore: Node.js global\n    // dnt-shim-ignore\n    : util != null && \"inspect\" in util && typeof util.inspect === \"function\"\n    ? (v, opts) =>\n      // @ts-ignore: Node.js global\n      // dnt-shim-ignore\n      util.inspect(v, {\n        maxArrayLength: Infinity,\n        maxStringLength: Infinity,\n        ...opts,\n      })\n    : (v) => JSON.stringify(v);\n\n/**\n * The formatted values for a log record.\n * @since 0.6.0\n */\nexport interface FormattedValues {\n  /**\n   * The formatted timestamp.\n   */\n  timestamp: string | null;\n\n  /**\n   * The formatted log level.\n   */\n  level: string;\n\n  /**\n   * The formatted category.\n   */\n  category: string;\n\n  /**\n   * The formatted message.\n   */\n  message: string;\n\n  /**\n   * The unformatted log record.\n   */\n  record: LogRecord;\n}\n\n/**\n * The various options for the built-in text formatters.\n * @since 0.6.0\n */\nexport interface TextFormatterOptions {\n  /**\n   * The timestamp format.  This can be one of the following:\n   *\n   * - `\"date-time-timezone\"`: The date and time with the full timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00:00\"`).\n   * - `\"date-time-tz\"`: The date and time with the short timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00\"`).\n   * - `\"date-time\"`: The date and time without the timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000\"`).\n   * - `\"time-timezone\"`: The time with the full timezone offset but without\n   *   the date (e.g., `\"22:13:20.000 +00:00\"`).\n   * - `\"time-tz\"`: The time with the short timezone offset but without the date\n   *   (e.g., `\"22:13:20.000 +00\"`).\n   * - `\"time\"`: The time without the date or timezone offset\n   *   (e.g., `\"22:13:20.000\"`).\n   * - `\"date\"`: The date without the time or timezone offset\n   *   (e.g., `\"2023-11-14\"`).\n   * - `\"rfc3339\"`: The date and time in RFC 3339 format\n   *   (e.g., `\"2023-11-14T22:13:20.000Z\"`).\n   * - `\"none\"` or `\"disabled\"`: No display\n   *\n   * Alternatively, this can be a function that accepts a timestamp and returns\n   * a string.\n   *\n   * The default is `\"date-time-timezone\"`.\n   */\n  timestamp?:\n    | \"date-time-timezone\"\n    | \"date-time-tz\"\n    | \"date-time\"\n    | \"time-timezone\"\n    | \"time-tz\"\n    | \"time\"\n    | \"date\"\n    | \"rfc3339\"\n    | \"none\"\n    | \"disabled\"\n    | ((ts: number) => string | null);\n\n  /**\n   * The log level format.  This can be one of the following:\n   *\n   * - `\"ABBR\"`: The log level abbreviation in uppercase (e.g., `\"INF\"`).\n   * - `\"FULL\"`: The full log level name in uppercase (e.g., `\"INFO\"`).\n   * - `\"L\"`: The first letter of the log level in uppercase (e.g., `\"I\"`).\n   * - `\"abbr\"`: The log level abbreviation in lowercase (e.g., `\"inf\"`).\n   * - `\"full\"`: The full log level name in lowercase (e.g., `\"info\"`).\n   * - `\"l\"`: The first letter of the log level in lowercase (e.g., `\"i\"`).\n   *\n   * Alternatively, this can be a function that accepts a log level and returns\n   * a string.\n   *\n   * The default is `\"ABBR\"`.\n   */\n  level?:\n    | \"ABBR\"\n    | \"FULL\"\n    | \"L\"\n    | \"abbr\"\n    | \"full\"\n    | \"l\"\n    | ((level: LogLevel) => string);\n\n  /**\n   * The separator between category names.  For example, if the separator is\n   * `\"\"`, the category `[\"a\", \"b\", \"c\"]` will be formatted as `\"abc\"`.\n   * The default separator is `\"\"`.\n   *\n   * If this is a function, it will be called with the category array and\n   * should return a string, which will be used for rendering the category.\n   */\n  category?: string | ((category: readonly string[]) => string);\n\n  /**\n   * The format of the embedded values.\n   *\n   * A function that renders a value to a string.  This function is used to\n   * render the values in the log record.  The default is [`util.inspect()`] in\n   * Node.js/Bun and [`Deno.inspect()`] in Deno.\n   *\n   * [`util.inspect()`]: https://nodejs.org/api/util.html#utilinspectobject-options\n   * [`Deno.inspect()`]: https://docs.deno.com/api/deno/~/Deno.inspect\n   * @param value The value to render.\n   * @returns The string representation of the value.\n   */\n  value?: (value: unknown) => string;\n\n  /**\n   * How those formatted parts are concatenated.\n   *\n   * A function that formats the log record.  This function is called with the\n   * formatted values and should return a string.  Note that the formatted\n   * *should not* include a newline character at the end.\n   *\n   * By default, this is a function that formats the log record as follows:\n   *\n   * ```\n   * 2023-11-14 22:13:20.000 +00:00 [INF] categorysubcategory: Hello, world!\n   * ```\n   * @param values The formatted values.\n   * @returns The formatted log record.\n   */\n  format?: (values: FormattedValues) => string;\n}\n\n// Optimized helper functions for timestamp formatting\nfunction padZero(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`;\n}\n\nfunction padThree(num: number): string {\n  return num < 10 ? `00${num}` : num < 100 ? `0${num}` : `${num}`;\n}\n\n// Pre-optimized timestamp formatter functions\nconst timestampFormatters = {\n  \"date-time-timezone\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms} +00:00`;\n  },\n  \"date-time-tz\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms} +00`;\n  },\n  \"date-time\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms}`;\n  },\n  \"time-timezone\": (ts: number): string => {\n    const d = new Date(ts);\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${hour}:${minute}:${second}.${ms} +00:00`;\n  },\n  \"time-tz\": (ts: number): string => {\n    const d = new Date(ts);\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${hour}:${minute}:${second}.${ms} +00`;\n  },\n  \"time\": (ts: number): string => {\n    const d = new Date(ts);\n    const hour = padZero(d.getUTCHours());\n    const minute = padZero(d.getUTCMinutes());\n    const second = padZero(d.getUTCSeconds());\n    const ms = padThree(d.getUTCMilliseconds());\n    return `${hour}:${minute}:${second}.${ms}`;\n  },\n  \"date\": (ts: number): string => {\n    const d = new Date(ts);\n    const year = d.getUTCFullYear();\n    const month = padZero(d.getUTCMonth() + 1);\n    const day = padZero(d.getUTCDate());\n    return `${year}-${month}-${day}`;\n  },\n  \"rfc3339\": (ts: number): string => new Date(ts).toISOString(),\n  \"none\": (): null => null,\n} as const;\n\n// Pre-computed level renderers for common cases\nconst levelRenderersCache = {\n  ABBR: levelAbbreviations,\n  abbr: {\n    trace: \"trc\",\n    debug: \"dbg\",\n    info: \"inf\",\n    warning: \"wrn\",\n    error: \"err\",\n    fatal: \"ftl\",\n  } as const,\n  FULL: {\n    trace: \"TRACE\",\n    debug: \"DEBUG\",\n    info: \"INFO\",\n    warning: \"WARNING\",\n    error: \"ERROR\",\n    fatal: \"FATAL\",\n  } as const,\n  full: {\n    trace: \"trace\",\n    debug: \"debug\",\n    info: \"info\",\n    warning: \"warning\",\n    error: \"error\",\n    fatal: \"fatal\",\n  } as const,\n  L: {\n    trace: \"T\",\n    debug: \"D\",\n    info: \"I\",\n    warning: \"W\",\n    error: \"E\",\n    fatal: \"F\",\n  } as const,\n  l: {\n    trace: \"t\",\n    debug: \"d\",\n    info: \"i\",\n    warning: \"w\",\n    error: \"e\",\n    fatal: \"f\",\n  } as const,\n} as const;\n\n/**\n * Get a text formatter with the specified options.  Although it's flexible\n * enough to create a custom formatter, if you want more control, you can\n * create a custom formatter that satisfies the {@link TextFormatter} type\n * instead.\n *\n * For more information on the options, see {@link TextFormatterOptions}.\n *\n * By default, the formatter formats log records as follows:\n *\n * ```\n * 2023-11-14 22:13:20.000 +00:00 [INF] categorysubcategory: Hello, world!\n * ```\n * @param options The options for the text formatter.\n * @returns The text formatter.\n * @since 0.6.0\n */\nexport function getTextFormatter(\n  options: TextFormatterOptions = {},\n): TextFormatter {\n  // Pre-compute timestamp formatter with optimized lookup\n  const timestampRenderer = (() => {\n    const tsOption = options.timestamp;\n    if (tsOption == null) {\n      return timestampFormatters[\"date-time-timezone\"];\n    } else if (tsOption === \"disabled\") {\n      return timestampFormatters[\"none\"];\n    } else if (\n      typeof tsOption === \"string\" && tsOption in timestampFormatters\n    ) {\n      return timestampFormatters[tsOption as keyof typeof timestampFormatters];\n    } else {\n      return tsOption as (ts: number) => string | null;\n    }\n  })();\n\n  const categorySeparator = options.category ?? \"\";\n  const valueRenderer = options.value ?? inspect;\n\n  // Pre-compute level renderer for better performance\n  const levelRenderer = (() => {\n    const levelOption = options.level;\n    if (levelOption == null || levelOption === \"ABBR\") {\n      return (level: LogLevel): string => levelRenderersCache.ABBR[level];\n    } else if (levelOption === \"abbr\") {\n      return (level: LogLevel): string => levelRenderersCache.abbr[level];\n    } else if (levelOption === \"FULL\") {\n      return (level: LogLevel): string => levelRenderersCache.FULL[level];\n    } else if (levelOption === \"full\") {\n      return (level: LogLevel): string => levelRenderersCache.full[level];\n    } else if (levelOption === \"L\") {\n      return (level: LogLevel): string => levelRenderersCache.L[level];\n    } else if (levelOption === \"l\") {\n      return (level: LogLevel): string => levelRenderersCache.l[level];\n    } else {\n      return levelOption;\n    }\n  })();\n\n  const formatter: (values: FormattedValues) => string = options.format ??\n    (({ timestamp, level, category, message }: FormattedValues) =>\n      `${timestamp ? `${timestamp} ` : \"\"}[${level}] ${category}: ${message}`);\n\n  return (record: LogRecord): string => {\n    // Optimized message building\n    const msgParts = record.message;\n    const msgLen = msgParts.length;\n\n    let message: string;\n    if (msgLen === 1) {\n      // Fast path for simple messages with no interpolation\n      message = msgParts[0] as string;\n    } else if (msgLen <= 6) {\n      // Fast path for small messages - direct concatenation\n      message = \"\";\n      for (let i = 0; i < msgLen; i++) {\n        message += (i % 2 === 0) ? msgParts[i] : valueRenderer(msgParts[i]);\n      }\n    } else {\n      // Optimized path for larger messages - array join\n      const parts: string[] = new Array(msgLen);\n      for (let i = 0; i < msgLen; i++) {\n        parts[i] = (i % 2 === 0)\n          ? msgParts[i] as string\n          : valueRenderer(msgParts[i]);\n      }\n      message = parts.join(\"\");\n    }\n\n    const timestamp = timestampRenderer(record.timestamp);\n    const level = levelRenderer(record.level);\n    const category = typeof categorySeparator === \"function\"\n      ? categorySeparator(record.category)\n      : record.category.join(categorySeparator);\n\n    const values: FormattedValues = {\n      timestamp,\n      level,\n      category,\n      message,\n      record,\n    };\n    return `${formatter(values)}\\n`;\n  };\n}\n\n/**\n * The default text formatter.  This formatter formats log records as follows:\n *\n * ```\n * 2023-11-14 22:13:20.000 +00:00 [INF] categorysubcategory: Hello, world!\n * ```\n *\n * @param record The log record to format.\n * @returns The formatted log record.\n */\nexport const defaultTextFormatter: TextFormatter = getTextFormatter();\n\nconst RESET = \"\\x1b[0m\";\n\n/**\n * The ANSI colors.  These can be used to colorize text in the console.\n * @since 0.6.0\n */\nexport type AnsiColor =\n  | \"black\"\n  | \"red\"\n  | \"green\"\n  | \"yellow\"\n  | \"blue\"\n  | \"magenta\"\n  | \"cyan\"\n  | \"white\";\n\nconst ansiColors: Record<AnsiColor, string> = {\n  black: \"\\x1b[30m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n};\n\n/**\n * The ANSI text styles.\n * @since 0.6.0\n */\nexport type AnsiStyle =\n  | \"bold\"\n  | \"dim\"\n  | \"italic\"\n  | \"underline\"\n  | \"strikethrough\";\n\nconst ansiStyles: Record<AnsiStyle, string> = {\n  bold: \"\\x1b[1m\",\n  dim: \"\\x1b[2m\",\n  italic: \"\\x1b[3m\",\n  underline: \"\\x1b[4m\",\n  strikethrough: \"\\x1b[9m\",\n};\n\nconst defaultLevelColors: Record<LogLevel, AnsiColor | null> = {\n  trace: null,\n  debug: \"blue\",\n  info: \"green\",\n  warning: \"yellow\",\n  error: \"red\",\n  fatal: \"magenta\",\n};\n\n/**\n * The various options for the ANSI color formatter.\n * @since 0.6.0\n */\nexport interface AnsiColorFormatterOptions extends TextFormatterOptions {\n  /**\n   * The timestamp format.  This can be one of the following:\n   *\n   * - `\"date-time-timezone\"`: The date and time with the full timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00:00\"`).\n   * - `\"date-time-tz\"`: The date and time with the short timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000 +00\"`).\n   * - `\"date-time\"`: The date and time without the timezone offset\n   *   (e.g., `\"2023-11-14 22:13:20.000\"`).\n   * - `\"time-timezone\"`: The time with the full timezone offset but without\n   *   the date (e.g., `\"22:13:20.000 +00:00\"`).\n   * - `\"time-tz\"`: The time with the short timezone offset but without the date\n   *   (e.g., `\"22:13:20.000 +00\"`).\n   * - `\"time\"`: The time without the date or timezone offset\n   *   (e.g., `\"22:13:20.000\"`).\n   * - `\"date\"`: The date without the time or timezone offset\n   *   (e.g., `\"2023-11-14\"`).\n   * - `\"rfc3339\"`: The date and time in RFC 3339 format\n   *   (e.g., `\"2023-11-14T22:13:20.000Z\"`).\n   *\n   * Alternatively, this can be a function that accepts a timestamp and returns\n   * a string.\n   *\n   * The default is `\"date-time-tz\"`.\n   */\n  timestamp?:\n    | \"date-time-timezone\"\n    | \"date-time-tz\"\n    | \"date-time\"\n    | \"time-timezone\"\n    | \"time-tz\"\n    | \"time\"\n    | \"date\"\n    | \"rfc3339\"\n    | ((ts: number) => string);\n\n  /**\n   * The ANSI style for the timestamp.  `\"dim\"` is used by default.\n   */\n  timestampStyle?: AnsiStyle | null;\n\n  /**\n   * The ANSI color for the timestamp.  No color is used by default.\n   */\n  timestampColor?: AnsiColor | null;\n\n  /**\n   * The ANSI style for the log level.  `\"bold\"` is used by default.\n   */\n  levelStyle?: AnsiStyle | null;\n\n  /**\n   * The ANSI colors for the log levels.  The default colors are as follows:\n   *\n   * - `\"trace\"`: `null` (no color)\n   * - `\"debug\"`: `\"blue\"`\n   * - `\"info\"`: `\"green\"`\n   * - `\"warning\"`: `\"yellow\"`\n   * - `\"error\"`: `\"red\"`\n   * - `\"fatal\"`: `\"magenta\"`\n   */\n  levelColors?: Record<LogLevel, AnsiColor | null>;\n\n  /**\n   * The ANSI style for the category.  `\"dim\"` is used by default.\n   */\n  categoryStyle?: AnsiStyle | null;\n\n  /**\n   * The ANSI color for the category.  No color is used by default.\n   */\n  categoryColor?: AnsiColor | null;\n}\n\n/**\n * Get an ANSI color formatter with the specified options.\n *\n * ![A preview of an ANSI color formatter.](https://i.imgur.com/I8LlBUf.png)\n * @param option The options for the ANSI color formatter.\n * @returns The ANSI color formatter.\n * @since 0.6.0\n */\nexport function getAnsiColorFormatter(\n  options: AnsiColorFormatterOptions = {},\n): TextFormatter {\n  const format = options.format;\n  const timestampStyle = typeof options.timestampStyle === \"undefined\"\n    ? \"dim\"\n    : options.timestampStyle;\n  const timestampColor = options.timestampColor ?? null;\n  const timestampPrefix = `${\n    timestampStyle == null ? \"\" : ansiStyles[timestampStyle]\n  }${timestampColor == null ? \"\" : ansiColors[timestampColor]}`;\n  const timestampSuffix = timestampStyle == null && timestampColor == null\n    ? \"\"\n    : RESET;\n  const levelStyle = typeof options.levelStyle === \"undefined\"\n    ? \"bold\"\n    : options.levelStyle;\n  const levelColors = options.levelColors ?? defaultLevelColors;\n  const categoryStyle = typeof options.categoryStyle === \"undefined\"\n    ? \"dim\"\n    : options.categoryStyle;\n  const categoryColor = options.categoryColor ?? null;\n  const categoryPrefix = `${\n    categoryStyle == null ? \"\" : ansiStyles[categoryStyle]\n  }${categoryColor == null ? \"\" : ansiColors[categoryColor]}`;\n  const categorySuffix = categoryStyle == null && categoryColor == null\n    ? \"\"\n    : RESET;\n  return getTextFormatter({\n    timestamp: \"date-time-tz\",\n    value(value: unknown): string {\n      return inspect(value, { colors: true });\n    },\n    ...options,\n    format({ timestamp, level, category, message, record }): string {\n      const levelColor = levelColors[record.level];\n      timestamp = `${timestampPrefix}${timestamp}${timestampSuffix}`;\n      level = `${levelStyle == null ? \"\" : ansiStyles[levelStyle]}${\n        levelColor == null ? \"\" : ansiColors[levelColor]\n      }${level}${levelStyle == null && levelColor == null ? \"\" : RESET}`;\n      return format == null\n        ? `${timestamp} ${level} ${categoryPrefix}${category}:${categorySuffix} ${message}`\n        : format({\n          timestamp,\n          level,\n          category: `${categoryPrefix}${category}${categorySuffix}`,\n          message,\n          record,\n        });\n    },\n  });\n}\n\n/**\n * A text formatter that uses ANSI colors to format log records.\n *\n * ![A preview of ansiColorFormatter.](https://i.imgur.com/I8LlBUf.png)\n *\n * @param record The log record to format.\n * @returns The formatted log record.\n * @since 0.5.0\n */\nexport const ansiColorFormatter: TextFormatter = getAnsiColorFormatter();\n\n/**\n * Options for the {@link getJsonLinesFormatter} function.\n * @since 0.11.0\n */\nexport interface JsonLinesFormatterOptions {\n  /**\n   * The separator between category names.  For example, if the separator is\n   * `\".\"`, the category `[\"a\", \"b\", \"c\"]` will be formatted as `\"a.b.c\"`.\n   * If this is a function, it will be called with the category array and\n   * should return a string or an array of strings, which will be used\n   * for rendering the category.\n   *\n   * @default `\".\"`\n   */\n  readonly categorySeparator?:\n    | string\n    | ((category: readonly string[]) => string | readonly string[]);\n\n  /**\n   * The message format.  This can be one of the following:\n   *\n   * - `\"template\"`: The raw message template is used as the message.\n   * - `\"rendered\"`: The message is rendered with the values.\n   *\n   * @default `\"rendered\"`\n   */\n  readonly message?: \"template\" | \"rendered\";\n\n  /**\n   * The properties format.  This can be one of the following:\n   *\n   * - `\"flatten\"`: The properties are flattened into the root object.\n   * - `\"prepend:<prefix>\"`: The properties are prepended with the given prefix\n   *   (e.g., `\"prepend:ctx_\"` will prepend `ctx_` to each property key).\n   * - `\"nest:<key>\"`: The properties are nested under the given key\n   *   (e.g., `\"nest:properties\"` will nest the properties under the\n   *   `properties` key).\n   *\n   * @default `\"nest:properties\"`\n   */\n  readonly properties?: \"flatten\" | `prepend:${string}` | `nest:${string}`;\n}\n\n/**\n * Get a [JSON Lines] formatter with the specified options.  The log records\n * will be rendered as JSON objects, one per line, which is a common format\n * for log files.  This format is also known as Newline-Delimited JSON (NDJSON).\n * It looks like this:\n *\n * ```json\n * {\"@timestamp\":\"2023-11-14T22:13:20.000Z\",\"level\":\"INFO\",\"message\":\"Hello, world!\",\"logger\":\"my.logger\",\"properties\":{\"key\":\"value\"}}\n * ```\n *\n * [JSON Lines]: https://jsonlines.org/\n * @param options The options for the JSON Lines formatter.\n * @returns The JSON Lines formatter.\n * @since 0.11.0\n */\nexport function getJsonLinesFormatter(\n  options: JsonLinesFormatterOptions = {},\n): TextFormatter {\n  // Most common configuration - optimize for the default case\n  if (!options.categorySeparator && !options.message && !options.properties) {\n    // Ultra-minimalist path - eliminate all possible overhead\n    return (record: LogRecord): string => {\n      // Direct benchmark pattern match (most common case first)\n      if (record.message.length === 3) {\n        return JSON.stringify({\n          \"@timestamp\": new Date(record.timestamp).toISOString(),\n          level: record.level === \"warning\"\n            ? \"WARN\"\n            : record.level.toUpperCase(),\n          message: record.message[0] + JSON.stringify(record.message[1]) +\n            record.message[2],\n          logger: record.category.join(\".\"),\n          properties: record.properties,\n        }) + \"\\n\";\n      }\n\n      // Single message (second most common)\n      if (record.message.length === 1) {\n        return JSON.stringify({\n          \"@timestamp\": new Date(record.timestamp).toISOString(),\n          level: record.level === \"warning\"\n            ? \"WARN\"\n            : record.level.toUpperCase(),\n          message: record.message[0],\n          logger: record.category.join(\".\"),\n          properties: record.properties,\n        }) + \"\\n\";\n      }\n\n      // Complex messages (fallback)\n      let msg = record.message[0] as string;\n      for (let i = 1; i < record.message.length; i++) {\n        msg += (i & 1) ? JSON.stringify(record.message[i]) : record.message[i];\n      }\n\n      return JSON.stringify({\n        \"@timestamp\": new Date(record.timestamp).toISOString(),\n        level: record.level === \"warning\" ? \"WARN\" : record.level.toUpperCase(),\n        message: msg,\n        logger: record.category.join(\".\"),\n        properties: record.properties,\n      }) + \"\\n\";\n    };\n  }\n\n  // Pre-compile configuration for non-default cases\n  const isTemplateMessage = options.message === \"template\";\n  const propertiesOption = options.properties ?? \"nest:properties\";\n\n  // Pre-compile category joining strategy\n  let joinCategory: (category: readonly string[]) => string | readonly string[];\n  if (typeof options.categorySeparator === \"function\") {\n    joinCategory = options.categorySeparator;\n  } else {\n    const separator = options.categorySeparator ?? \".\";\n    joinCategory = (category: readonly string[]): string =>\n      category.join(separator);\n  }\n\n  // Pre-compile properties handling strategy\n  let getProperties: (\n    properties: Record<string, unknown>,\n  ) => Record<string, unknown>;\n\n  if (propertiesOption === \"flatten\") {\n    getProperties = (properties) => properties;\n  } else if (propertiesOption.startsWith(\"prepend:\")) {\n    const prefix = propertiesOption.substring(8);\n    if (prefix === \"\") {\n      throw new TypeError(\n        `Invalid properties option: ${\n          JSON.stringify(propertiesOption)\n        }. It must be of the form \"prepend:<prefix>\" where <prefix> is a non-empty string.`,\n      );\n    }\n    getProperties = (properties) => {\n      const result: Record<string, unknown> = {};\n      for (const key in properties) {\n        result[`${prefix}${key}`] = properties[key];\n      }\n      return result;\n    };\n  } else if (propertiesOption.startsWith(\"nest:\")) {\n    const key = propertiesOption.substring(5);\n    getProperties = (properties) => ({ [key]: properties });\n  } else {\n    throw new TypeError(\n      `Invalid properties option: ${\n        JSON.stringify(propertiesOption)\n      }. It must be \"flatten\", \"prepend:<prefix>\", or \"nest:<key>\".`,\n    );\n  }\n\n  // Pre-compile message rendering function\n  let getMessage: (record: LogRecord) => string;\n\n  if (isTemplateMessage) {\n    getMessage = (record: LogRecord): string => {\n      if (typeof record.rawMessage === \"string\") {\n        return record.rawMessage;\n      }\n      let msg = \"\";\n      for (let i = 0; i < record.rawMessage.length; i++) {\n        msg += i % 2 < 1 ? record.rawMessage[i] : \"{}\";\n      }\n      return msg;\n    };\n  } else {\n    getMessage = (record: LogRecord): string => {\n      const msgLen = record.message.length;\n\n      if (msgLen === 1) {\n        return record.message[0] as string;\n      }\n\n      let msg = \"\";\n      for (let i = 0; i < msgLen; i++) {\n        msg += (i % 2 < 1)\n          ? record.message[i]\n          : JSON.stringify(record.message[i]);\n      }\n      return msg;\n    };\n  }\n\n  return (record: LogRecord): string => {\n    return JSON.stringify({\n      \"@timestamp\": new Date(record.timestamp).toISOString(),\n      level: record.level === \"warning\" ? \"WARN\" : record.level.toUpperCase(),\n      message: getMessage(record),\n      logger: joinCategory(record.category),\n      ...getProperties(record.properties),\n    }) + \"\\n\";\n  };\n}\n\n/**\n * The default [JSON Lines] formatter.  This formatter formats log records\n * as JSON objects, one per line, which is a common format for log files.\n * It looks like this:\n *\n * ```json\n * {\"@timestamp\":\"2023-11-14T22:13:20.000Z\",\"level\":\"INFO\",\"message\":\"Hello, world!\",\"logger\":\"my.logger\",\"properties\":{\"key\":\"value\"}}\n * ```\n *\n * You can customize the output by passing options to\n * {@link getJsonLinesFormatter}.  For example, you can change the category\n * separator, the message format, and how the properties are formatted.\n *\n * [JSON Lines]: https://jsonlines.org/\n * @since 0.11.0\n */\nexport const jsonLinesFormatter: TextFormatter = getJsonLinesFormatter();\n\n/**\n * A console formatter is a function that accepts a log record and returns\n * an array of arguments to pass to {@link console.log}.\n *\n * @param record The log record to format.\n * @returns The formatted log record, as an array of arguments for\n *          {@link console.log}.\n */\nexport type ConsoleFormatter = (record: LogRecord) => readonly unknown[];\n\n/**\n * The styles for the log level in the console.\n */\nconst logLevelStyles: Record<LogLevel, string> = {\n  \"trace\": \"background-color: gray; color: white;\",\n  \"debug\": \"background-color: gray; color: white;\",\n  \"info\": \"background-color: white; color: black;\",\n  \"warning\": \"background-color: orange; color: black;\",\n  \"error\": \"background-color: red; color: white;\",\n  \"fatal\": \"background-color: maroon; color: white;\",\n};\n\n/**\n * The default console formatter.\n *\n * @param record The log record to format.\n * @returns The formatted log record, as an array of arguments for\n *          {@link console.log}.\n */\nexport function defaultConsoleFormatter(record: LogRecord): readonly unknown[] {\n  let msg = \"\";\n  const values: unknown[] = [];\n  for (let i = 0; i < record.message.length; i++) {\n    if (i % 2 === 0) msg += record.message[i];\n    else {\n      msg += \"%o\";\n      values.push(record.message[i]);\n    }\n  }\n  const date = new Date(record.timestamp);\n  const time = `${date.getUTCHours().toString().padStart(2, \"0\")}:${\n    date.getUTCMinutes().toString().padStart(2, \"0\")\n  }:${date.getUTCSeconds().toString().padStart(2, \"0\")}.${\n    date.getUTCMilliseconds().toString().padStart(3, \"0\")\n  }`;\n  return [\n    `%c${time} %c${levelAbbreviations[record.level]}%c %c${\n      record.category.join(\"\\xb7\")\n    } %c${msg}`,\n    \"color: gray;\",\n    logLevelStyles[record.level],\n    \"background-color: default;\",\n    \"color: gray;\",\n    \"color: default;\",\n    ...values,\n  ];\n}\n", "import { type FilterLike, toFilter } from \"./filter.ts\";\nimport {\n  type ConsoleFormatter,\n  defaultConsoleFormatter,\n  defaultTextFormatter,\n  type TextFormatter,\n} from \"./formatter.ts\";\nimport { compareLogLevel, type LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\n\n/**\n * A sink is a function that accepts a log record and prints it somewhere.\n * Thrown exceptions will be suppressed and then logged to the meta logger,\n * a {@link Logger} with the category `[\"logtape\", \"meta\"]`.  (In that case,\n * the meta log record will not be passed to the sink to avoid infinite\n * recursion.)\n *\n * @param record The log record to sink.\n */\nexport type Sink = (record: LogRecord) => void;\n\n/**\n * An async sink is a function that accepts a log record and asynchronously\n * processes it. This type is used with {@link fromAsyncSink} to create\n * a regular sink that properly handles asynchronous operations.\n *\n * @param record The log record to process asynchronously.\n * @returns A promise that resolves when the record has been processed.\n * @since 1.0.0\n */\nexport type AsyncSink = (record: LogRecord) => Promise<void>;\n\n/**\n * Turns a sink into a filtered sink.  The returned sink only logs records that\n * pass the filter.\n *\n * @example Filter a console sink to only log records with the info level\n * ```typescript\n * const sink = withFilter(getConsoleSink(), \"info\");\n * ```\n *\n * @param sink A sink to be filtered.\n * @param filter A filter to apply to the sink.  It can be either a filter\n *               function or a {@link LogLevel} string.\n * @returns A sink that only logs records that pass the filter.\n */\nexport function withFilter(sink: Sink, filter: FilterLike): Sink {\n  const filterFunc = toFilter(filter);\n  return (record: LogRecord) => {\n    if (filterFunc(record)) sink(record);\n  };\n}\n\n/**\n * Options for the {@link getStreamSink} function.\n */\nexport interface StreamSinkOptions {\n  /**\n   * The text formatter to use.  Defaults to {@link defaultTextFormatter}.\n   */\n  formatter?: TextFormatter;\n\n  /**\n   * The text encoder to use.  Defaults to an instance of {@link TextEncoder}.\n   */\n  encoder?: { encode(text: string): Uint8Array };\n\n  /**\n   * Enable non-blocking mode with optional buffer configuration.\n   * When enabled, log records are buffered and flushed in the background.\n   *\n   * @example Simple non-blocking mode\n   * ```typescript\n   * getStreamSink(stream, { nonBlocking: true });\n   * ```\n   *\n   * @example Custom buffer configuration\n   * ```typescript\n   * getStreamSink(stream, {\n   *   nonBlocking: {\n   *     bufferSize: 1000,\n   *     flushInterval: 50\n   *   }\n   * });\n   * ```\n   *\n   * @default `false`\n   * @since 1.0.0\n   */\n  nonBlocking?: boolean | {\n    /**\n     * Maximum number of records to buffer before flushing.\n     * @default `100`\n     */\n    bufferSize?: number;\n\n    /**\n     * Interval in milliseconds between automatic flushes.\n     * @default `100`\n     */\n    flushInterval?: number;\n  };\n}\n\n/**\n * A factory that returns a sink that writes to a {@link WritableStream}.\n *\n * Note that the `stream` is of Web Streams API, which is different from\n * Node.js streams.  You can convert a Node.js stream to a Web Streams API\n * stream using [`stream.Writable.toWeb()`] method.\n *\n * [`stream.Writable.toWeb()`]: https://nodejs.org/api/stream.html#streamwritabletowebstreamwritable\n *\n * @example Sink to the standard error in Deno\n * ```typescript\n * const stderrSink = getStreamSink(Deno.stderr.writable);\n * ```\n *\n * @example Sink to the standard error in Node.js\n * ```typescript\n * import stream from \"node:stream\";\n * const stderrSink = getStreamSink(stream.Writable.toWeb(process.stderr));\n * ```\n *\n * @param stream The stream to write to.\n * @param options The options for the sink.\n * @returns A sink that writes to the stream.\n */\nexport function getStreamSink(\n  stream: WritableStream,\n  options: StreamSinkOptions = {},\n): Sink & AsyncDisposable {\n  const formatter = options.formatter ?? defaultTextFormatter;\n  const encoder = options.encoder ?? new TextEncoder();\n  const writer = stream.getWriter();\n\n  if (!options.nonBlocking) {\n    let lastPromise = Promise.resolve();\n    const sink: Sink & AsyncDisposable = (record: LogRecord) => {\n      const bytes = encoder.encode(formatter(record));\n      lastPromise = lastPromise\n        .then(() => writer.ready)\n        .then(() => writer.write(bytes));\n    };\n    sink[Symbol.asyncDispose] = async () => {\n      await lastPromise;\n      await writer.close();\n    };\n    return sink;\n  }\n\n  // Non-blocking mode implementation\n  const nonBlockingConfig = options.nonBlocking === true\n    ? {}\n    : options.nonBlocking;\n  const bufferSize = nonBlockingConfig.bufferSize ?? 100;\n  const flushInterval = nonBlockingConfig.flushInterval ?? 100;\n\n  const buffer: LogRecord[] = [];\n  let flushTimer: ReturnType<typeof setInterval> | null = null;\n  let disposed = false;\n  let activeFlush: Promise<void> | null = null;\n  const maxBufferSize = bufferSize * 2; // Overflow protection\n\n  async function flush(): Promise<void> {\n    if (buffer.length === 0) return;\n\n    const records = buffer.splice(0);\n    for (const record of records) {\n      try {\n        const bytes = encoder.encode(formatter(record));\n        await writer.ready;\n        await writer.write(bytes);\n      } catch {\n        // Silently ignore errors in non-blocking mode to avoid disrupting the application\n      }\n    }\n  }\n\n  function scheduleFlush(): void {\n    if (activeFlush) return;\n\n    activeFlush = flush().finally(() => {\n      activeFlush = null;\n    });\n  }\n\n  function startFlushTimer(): void {\n    if (flushTimer !== null || disposed) return;\n\n    flushTimer = setInterval(() => {\n      scheduleFlush();\n    }, flushInterval);\n  }\n\n  const nonBlockingSink: Sink & AsyncDisposable = (record: LogRecord) => {\n    if (disposed) return;\n\n    // Buffer overflow protection: drop oldest records if buffer is too large\n    if (buffer.length >= maxBufferSize) {\n      buffer.shift(); // Remove oldest record\n    }\n\n    buffer.push(record);\n\n    if (buffer.length >= bufferSize) {\n      scheduleFlush();\n    } else if (flushTimer === null) {\n      startFlushTimer();\n    }\n  };\n\n  nonBlockingSink[Symbol.asyncDispose] = async () => {\n    disposed = true;\n    if (flushTimer !== null) {\n      clearInterval(flushTimer);\n      flushTimer = null;\n    }\n    await flush();\n    try {\n      await writer.close();\n    } catch {\n      // Writer might already be closed or errored\n    }\n  };\n\n  return nonBlockingSink;\n}\n\ntype ConsoleMethod = \"debug\" | \"info\" | \"log\" | \"warn\" | \"error\";\n\n/**\n * Options for the {@link getConsoleSink} function.\n */\nexport interface ConsoleSinkOptions {\n  /**\n   * The console formatter or text formatter to use.\n   * Defaults to {@link defaultConsoleFormatter}.\n   */\n  formatter?: ConsoleFormatter | TextFormatter;\n\n  /**\n   * The mapping from log levels to console methods.  Defaults to:\n   *\n   * ```typescript\n   * {\n   *   trace: \"trace\",\n   *   debug: \"debug\",\n   *   info: \"info\",\n   *   warning: \"warn\",\n   *   error: \"error\",\n   *   fatal: \"error\",\n   * }\n   * ```\n   * @since 0.9.0\n   */\n  levelMap?: Record<LogLevel, ConsoleMethod>;\n\n  /**\n   * The console to log to.  Defaults to {@link console}.\n   */\n  console?: Console;\n\n  /**\n   * Enable non-blocking mode with optional buffer configuration.\n   * When enabled, log records are buffered and flushed in the background.\n   *\n   * @example Simple non-blocking mode\n   * ```typescript\n   * getConsoleSink({ nonBlocking: true });\n   * ```\n   *\n   * @example Custom buffer configuration\n   * ```typescript\n   * getConsoleSink({\n   *   nonBlocking: {\n   *     bufferSize: 1000,\n   *     flushInterval: 50\n   *   }\n   * });\n   * ```\n   *\n   * @default `false`\n   * @since 1.0.0\n   */\n  nonBlocking?: boolean | {\n    /**\n     * Maximum number of records to buffer before flushing.\n     * @default `100`\n     */\n    bufferSize?: number;\n\n    /**\n     * Interval in milliseconds between automatic flushes.\n     * @default `100`\n     */\n    flushInterval?: number;\n  };\n}\n\n/**\n * A console sink factory that returns a sink that logs to the console.\n *\n * @param options The options for the sink.\n * @returns A sink that logs to the console. If `nonBlocking` is enabled,\n *          returns a sink that also implements {@link Disposable}.\n */\nexport function getConsoleSink(\n  options: ConsoleSinkOptions = {},\n): Sink | (Sink & Disposable) {\n  const formatter = options.formatter ?? defaultConsoleFormatter;\n  const levelMap: Record<LogLevel, ConsoleMethod> = {\n    trace: \"debug\",\n    debug: \"debug\",\n    info: \"info\",\n    warning: \"warn\",\n    error: \"error\",\n    fatal: \"error\",\n    ...(options.levelMap ?? {}),\n  };\n  const console = options.console ?? globalThis.console;\n\n  const baseSink = (record: LogRecord) => {\n    const args = formatter(record);\n    const method = levelMap[record.level];\n    if (method === undefined) {\n      throw new TypeError(`Invalid log level: ${record.level}.`);\n    }\n    if (typeof args === \"string\") {\n      const msg = args.replace(/\\r?\\n$/, \"\");\n      console[method](msg);\n    } else {\n      console[method](...args);\n    }\n  };\n\n  if (!options.nonBlocking) {\n    return baseSink;\n  }\n\n  // Non-blocking mode implementation\n  const nonBlockingConfig = options.nonBlocking === true\n    ? {}\n    : options.nonBlocking;\n  const bufferSize = nonBlockingConfig.bufferSize ?? 100;\n  const flushInterval = nonBlockingConfig.flushInterval ?? 100;\n\n  const buffer: LogRecord[] = [];\n  let flushTimer: ReturnType<typeof setInterval> | null = null;\n  let disposed = false;\n  let flushScheduled = false;\n  const maxBufferSize = bufferSize * 2; // Overflow protection\n\n  function flush(): void {\n    if (buffer.length === 0) return;\n\n    const records = buffer.splice(0);\n    for (const record of records) {\n      try {\n        baseSink(record);\n      } catch {\n        // Silently ignore errors in non-blocking mode to avoid disrupting the application\n      }\n    }\n  }\n\n  function scheduleFlush(): void {\n    if (flushScheduled) return;\n\n    flushScheduled = true;\n    setTimeout(() => {\n      flushScheduled = false;\n      flush();\n    }, 0);\n  }\n\n  function startFlushTimer(): void {\n    if (flushTimer !== null || disposed) return;\n\n    flushTimer = setInterval(() => {\n      flush();\n    }, flushInterval);\n  }\n\n  const nonBlockingSink: Sink & Disposable = (record: LogRecord) => {\n    if (disposed) return;\n\n    // Buffer overflow protection: drop oldest records if buffer is too large\n    if (buffer.length >= maxBufferSize) {\n      buffer.shift(); // Remove oldest record\n    }\n\n    buffer.push(record);\n\n    if (buffer.length >= bufferSize) {\n      scheduleFlush();\n    } else if (flushTimer === null) {\n      startFlushTimer();\n    }\n  };\n\n  nonBlockingSink[Symbol.dispose] = () => {\n    disposed = true;\n    if (flushTimer !== null) {\n      clearInterval(flushTimer);\n      flushTimer = null;\n    }\n    flush();\n  };\n\n  return nonBlockingSink;\n}\n\n/**\n * Converts an async sink into a regular sink with proper async handling.\n * The returned sink chains async operations to ensure proper ordering and\n * implements AsyncDisposable to wait for all pending operations on disposal.\n *\n * @example Create a sink that asynchronously posts to a webhook\n * ```typescript\n * const asyncSink: AsyncSink = async (record) => {\n *   await fetch(\"https://example.com/logs\", {\n *     method: \"POST\",\n *     body: JSON.stringify(record),\n *   });\n * };\n * const sink = fromAsyncSink(asyncSink);\n * ```\n *\n * @param asyncSink The async sink function to convert.\n * @returns A sink that properly handles async operations and disposal.\n * @since 1.0.0\n */\nexport function fromAsyncSink(asyncSink: AsyncSink): Sink & AsyncDisposable {\n  let lastPromise = Promise.resolve();\n  const sink: Sink & AsyncDisposable = (record: LogRecord) => {\n    lastPromise = lastPromise\n      .then(() => asyncSink(record))\n      .catch(() => {\n        // Errors are handled by the sink infrastructure\n      });\n  };\n  sink[Symbol.asyncDispose] = async () => {\n    await lastPromise;\n  };\n  return sink;\n}\n\n/**\n * Options for the {@link fingersCrossed} function.\n * @since 1.1.0\n */\nexport interface FingersCrossedOptions {\n  /**\n   * Minimum log level that triggers buffer flush.\n   * When a log record at or above this level is received, all buffered\n   * records are flushed to the wrapped sink.\n   * @default `\"error\"`\n   */\n  readonly triggerLevel?: LogLevel;\n\n  /**\n   * Maximum buffer size before oldest records are dropped.\n   * When the buffer exceeds this size, the oldest records are removed\n   * to prevent unbounded memory growth.\n   * @default `1000`\n   */\n  readonly maxBufferSize?: number;\n\n  /**\n   * Category isolation mode or custom matcher function.\n   *\n   * When `undefined` (default), all log records share a single buffer.\n   *\n   * When set to a mode string:\n   *\n   * - `\"descendant\"`: Flush child category buffers when parent triggers\n   * - `\"ancestor\"`: Flush parent category buffers when child triggers\n   * - `\"both\"`: Flush both parent and child category buffers\n   *\n   * When set to a function, it receives the trigger category and buffered\n   * category and should return true if the buffered category should be flushed.\n   *\n   * @default `undefined` (no isolation, single global buffer)\n   */\n  readonly isolateByCategory?:\n    | \"descendant\"\n    | \"ancestor\"\n    | \"both\"\n    | ((\n      triggerCategory: readonly string[],\n      bufferedCategory: readonly string[],\n    ) => boolean);\n}\n\n/**\n * Creates a sink that buffers log records until a trigger level is reached.\n * This pattern, known as \"fingers crossed\" logging, keeps detailed debug logs\n * in memory and only outputs them when an error or other significant event occurs.\n *\n * @example Basic usage with default settings\n * ```typescript\n * const sink = fingersCrossed(getConsoleSink());\n * // Debug and info logs are buffered\n * // When an error occurs, all buffered logs + the error are output\n * ```\n *\n * @example Custom trigger level and buffer size\n * ```typescript\n * const sink = fingersCrossed(getConsoleSink(), {\n *   triggerLevel: \"warning\",  // Trigger on warning or higher\n *   maxBufferSize: 500        // Keep last 500 records\n * });\n * ```\n *\n * @example Category isolation\n * ```typescript\n * const sink = fingersCrossed(getConsoleSink(), {\n *   isolateByCategory: \"descendant\"  // Separate buffers per category\n * });\n * // Error in [\"app\"] triggers flush of [\"app\"] and [\"app\", \"module\"] buffers\n * // But not [\"other\"] buffer\n * ```\n *\n * @param sink The sink to wrap. Buffered records are sent to this sink when\n *             triggered.\n * @param options Configuration options for the fingers crossed behavior.\n * @returns A sink that buffers records until the trigger level is reached.\n * @since 1.1.0\n */\nexport function fingersCrossed(\n  sink: Sink,\n  options: FingersCrossedOptions = {},\n): Sink {\n  const triggerLevel = options.triggerLevel ?? \"error\";\n  const maxBufferSize = Math.max(0, options.maxBufferSize ?? 1000);\n  const isolateByCategory = options.isolateByCategory;\n\n  // Validate trigger level early\n  try {\n    compareLogLevel(\"trace\", triggerLevel); // Test with any valid level\n  } catch (error) {\n    throw new TypeError(\n      `Invalid triggerLevel: ${JSON.stringify(triggerLevel)}. ${\n        error instanceof Error ? error.message : String(error)\n      }`,\n    );\n  }\n\n  // Helper functions for category matching\n  function isDescendant(\n    parent: readonly string[],\n    child: readonly string[],\n  ): boolean {\n    if (parent.length === 0 || child.length === 0) return false; // Empty categories are isolated\n    if (parent.length > child.length) return false;\n    return parent.every((p, i) => p === child[i]);\n  }\n\n  function isAncestor(\n    child: readonly string[],\n    parent: readonly string[],\n  ): boolean {\n    if (child.length === 0 || parent.length === 0) return false; // Empty categories are isolated\n    if (child.length < parent.length) return false;\n    return parent.every((p, i) => p === child[i]);\n  }\n\n  // Determine matcher function based on isolation mode\n  let shouldFlushBuffer:\n    | ((\n      triggerCategory: readonly string[],\n      bufferedCategory: readonly string[],\n    ) => boolean)\n    | null = null;\n\n  if (isolateByCategory) {\n    if (typeof isolateByCategory === \"function\") {\n      shouldFlushBuffer = isolateByCategory;\n    } else {\n      switch (isolateByCategory) {\n        case \"descendant\":\n          shouldFlushBuffer = (trigger, buffered) =>\n            isDescendant(trigger, buffered);\n          break;\n        case \"ancestor\":\n          shouldFlushBuffer = (trigger, buffered) =>\n            isAncestor(trigger, buffered);\n          break;\n        case \"both\":\n          shouldFlushBuffer = (trigger, buffered) =>\n            isDescendant(trigger, buffered) || isAncestor(trigger, buffered);\n          break;\n      }\n    }\n  }\n\n  // Helper functions for category serialization\n  function getCategoryKey(category: readonly string[]): string {\n    return JSON.stringify(category);\n  }\n\n  function parseCategoryKey(key: string): string[] {\n    return JSON.parse(key);\n  }\n\n  // Buffer management\n  if (!isolateByCategory) {\n    // Single global buffer\n    const buffer: LogRecord[] = [];\n    let triggered = false;\n\n    return (record: LogRecord) => {\n      if (triggered) {\n        // Already triggered, pass through directly\n        sink(record);\n        return;\n      }\n\n      // Check if this record triggers flush\n      if (compareLogLevel(record.level, triggerLevel) >= 0) {\n        triggered = true;\n\n        // Flush buffer\n        for (const bufferedRecord of buffer) {\n          sink(bufferedRecord);\n        }\n        buffer.length = 0;\n\n        // Send trigger record\n        sink(record);\n      } else {\n        // Buffer the record\n        buffer.push(record);\n\n        // Enforce max buffer size\n        while (buffer.length > maxBufferSize) {\n          buffer.shift();\n        }\n      }\n    };\n  } else {\n    // Category-isolated buffers\n    const buffers = new Map<string, LogRecord[]>();\n    const triggered = new Set<string>();\n\n    return (record: LogRecord) => {\n      const categoryKey = getCategoryKey(record.category);\n\n      // Check if this category is already triggered\n      if (triggered.has(categoryKey)) {\n        sink(record);\n        return;\n      }\n\n      // Check if this record triggers flush\n      if (compareLogLevel(record.level, triggerLevel) >= 0) {\n        // Find all buffers that should be flushed\n        const keysToFlush = new Set<string>();\n\n        for (const [bufferedKey] of buffers) {\n          if (bufferedKey === categoryKey) {\n            keysToFlush.add(bufferedKey);\n          } else if (shouldFlushBuffer) {\n            const bufferedCategory = parseCategoryKey(bufferedKey);\n            try {\n              if (shouldFlushBuffer(record.category, bufferedCategory)) {\n                keysToFlush.add(bufferedKey);\n              }\n            } catch {\n              // Ignore errors from custom matcher\n            }\n          }\n        }\n\n        // Flush matching buffers\n        const allRecordsToFlush: LogRecord[] = [];\n        for (const key of keysToFlush) {\n          const buffer = buffers.get(key);\n          if (buffer) {\n            allRecordsToFlush.push(...buffer);\n            buffers.delete(key);\n            triggered.add(key);\n          }\n        }\n\n        // Sort by timestamp to maintain chronological order\n        allRecordsToFlush.sort((a, b) => a.timestamp - b.timestamp);\n\n        // Flush all records\n        for (const bufferedRecord of allRecordsToFlush) {\n          sink(bufferedRecord);\n        }\n\n        // Mark trigger category as triggered and send trigger record\n        triggered.add(categoryKey);\n        sink(record);\n      } else {\n        // Buffer the record\n        let buffer = buffers.get(categoryKey);\n        if (!buffer) {\n          buffer = [];\n          buffers.set(categoryKey, buffer);\n        }\n\n        buffer.push(record);\n\n        // Enforce max buffer size per category\n        while (buffer.length > maxBufferSize) {\n          buffer.shift();\n        }\n      }\n    };\n  }\n}\n", "import type { ContextLocalStorage } from \"./context.ts\";\nimport { type FilterLike, toFilter } from \"./filter.ts\";\nimport type { LogLevel } from \"./level.ts\";\nimport { LoggerImpl } from \"./logger.ts\";\nimport { getConsoleSink, type Sink } from \"./sink.ts\";\n\n/**\n * A configuration for the loggers.\n */\nexport interface Config<TSinkId extends string, TFilterId extends string> {\n  /**\n   * The sinks to use.  The keys are the sink identifiers, and the values are\n   * {@link Sink}s.\n   */\n  sinks: Record<TSinkId, Sink>;\n  /**\n   * The filters to use.  The keys are the filter identifiers, and the values\n   * are either {@link Filter}s or {@link LogLevel}s.\n   */\n  filters?: Record<TFilterId, FilterLike>;\n\n  /**\n   * The loggers to configure.\n   */\n  loggers: LoggerConfig<TSinkId, TFilterId>[];\n\n  /**\n   * The context-local storage to use for implicit contexts.\n   * @since 0.7.0\n   */\n  contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;\n\n  /**\n   * Whether to reset the configuration before applying this one.\n   */\n  reset?: boolean;\n}\n\n/**\n * A logger configuration.\n */\nexport interface LoggerConfig<\n  TSinkId extends string,\n  TFilterId extends string,\n> {\n  /**\n   * The category of the logger.  If a string, it is equivalent to an array\n   * with one element.\n   */\n  category: string | string[];\n\n  /**\n   * The sink identifiers to use.\n   */\n  sinks?: TSinkId[];\n\n  /**\n   * Whether to inherit the parent's sinks.  If `inherit`, the parent's sinks\n   * are used along with the specified sinks.  If `override`, the parent's\n   * sinks are not used, and only the specified sinks are used.\n   *\n   * The default is `inherit`.\n   * @default `\"inherit\"\n   * @since 0.6.0\n   */\n  parentSinks?: \"inherit\" | \"override\";\n\n  /**\n   * The filter identifiers to use.\n   */\n  filters?: TFilterId[];\n\n  /**\n   * The lowest log level to accept.  If `null`, the logger will reject all\n   * records.\n   * @since 0.8.0\n   */\n  lowestLevel?: LogLevel | null;\n}\n\n/**\n * The current configuration, if any.  Otherwise, `null`.\n */\nlet currentConfig: Config<string, string> | null = null;\n\n/**\n * Strong references to the loggers.\n * This is to prevent the loggers from being garbage collected so that their\n * sinks and filters are not removed.\n */\nconst strongRefs: Set<LoggerImpl> = new Set();\n\n/**\n * Disposables to dispose when resetting the configuration.\n */\nconst disposables: Set<Disposable> = new Set();\n\n/**\n * Async disposables to dispose when resetting the configuration.\n */\nconst asyncDisposables: Set<AsyncDisposable> = new Set();\n\n/**\n * Check if a config is for the meta logger.\n */\nfunction isLoggerConfigMeta<TSinkId extends string, TFilterId extends string>(\n  cfg: LoggerConfig<TSinkId, TFilterId>,\n): boolean {\n  return cfg.category.length === 0 ||\n    (cfg.category.length === 1 && cfg.category[0] === \"logtape\") ||\n    (cfg.category.length === 2 &&\n      cfg.category[0] === \"logtape\" &&\n      cfg.category[1] === \"meta\");\n}\n\n/**\n * Configure the loggers with the specified configuration.\n *\n * Note that if the given sinks or filters are disposable, they will be\n * disposed when the configuration is reset, or when the process exits.\n *\n * @example\n * ```typescript\n * await configure({\n *   sinks: {\n *     console: getConsoleSink(),\n *   },\n *   filters: {\n *     slow: (log) =>\n *       \"duration\" in log.properties &&\n *       log.properties.duration as number > 1000,\n *   },\n *   loggers: [\n *     {\n *       category: \"my-app\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"info\",\n *     },\n *     {\n *       category: [\"my-app\", \"sql\"],\n *       filters: [\"slow\"],\n *       lowestLevel: \"debug\",\n *     },\n *     {\n *       category: \"logtape\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"error\",\n *     },\n *   ],\n * });\n * ```\n *\n * @param config The configuration.\n */\nexport async function configure<\n  TSinkId extends string,\n  TFilterId extends string,\n>(config: Config<TSinkId, TFilterId>): Promise<void> {\n  if (currentConfig != null && !config.reset) {\n    throw new ConfigError(\n      \"Already configured; if you want to reset, turn on the reset flag.\",\n    );\n  }\n  await reset();\n  try {\n    configureInternal(config, true);\n  } catch (e) {\n    if (e instanceof ConfigError) await reset();\n    throw e;\n  }\n}\n\n/**\n * Configure sync loggers with the specified configuration.\n *\n * Note that if the given sinks or filters are disposable, they will be\n * disposed when the configuration is reset, or when the process exits.\n *\n * Also note that passing async sinks or filters will throw. If\n * necessary use {@link resetSync} or {@link disposeSync}.\n *\n * @example\n * ```typescript\n * configureSync({\n *   sinks: {\n *     console: getConsoleSink(),\n *   },\n *   loggers: [\n *     {\n *       category: \"my-app\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"info\",\n *     },\n *     {\n *       category: \"logtape\",\n *       sinks: [\"console\"],\n *       lowestLevel: \"error\",\n *     },\n *   ],\n * });\n * ```\n *\n * @param config The configuration.\n * @since 0.9.0\n */\nexport function configureSync<TSinkId extends string, TFilterId extends string>(\n  config: Config<TSinkId, TFilterId>,\n): void {\n  if (currentConfig != null && !config.reset) {\n    throw new ConfigError(\n      \"Already configured; if you want to reset, turn on the reset flag.\",\n    );\n  }\n  if (asyncDisposables.size > 0) {\n    throw new ConfigError(\n      \"Previously configured async disposables are still active. \" +\n        \"Use configure() instead or explicitly dispose them using dispose().\",\n    );\n  }\n  resetSync();\n  try {\n    configureInternal(config, false);\n  } catch (e) {\n    if (e instanceof ConfigError) resetSync();\n    throw e;\n  }\n}\n\nfunction configureInternal<\n  TSinkId extends string,\n  TFilterId extends string,\n>(config: Config<TSinkId, TFilterId>, allowAsync: boolean): void {\n  currentConfig = config;\n\n  let metaConfigured = false;\n  const configuredCategories = new Set<string>();\n\n  for (const cfg of config.loggers) {\n    if (isLoggerConfigMeta(cfg)) {\n      metaConfigured = true;\n    }\n\n    // Check for duplicate logger categories\n    const categoryKey = Array.isArray(cfg.category)\n      ? JSON.stringify(cfg.category)\n      : JSON.stringify([cfg.category]);\n    if (configuredCategories.has(categoryKey)) {\n      throw new ConfigError(\n        `Duplicate logger configuration for category: ${categoryKey}. ` +\n          `Each category can only be configured once.`,\n      );\n    }\n    configuredCategories.add(categoryKey);\n\n    const logger = LoggerImpl.getLogger(cfg.category);\n    for (const sinkId of cfg.sinks ?? []) {\n      const sink = config.sinks[sinkId];\n      if (!sink) {\n        throw new ConfigError(`Sink not found: ${sinkId}.`);\n      }\n      logger.sinks.push(sink);\n    }\n    logger.parentSinks = cfg.parentSinks ?? \"inherit\";\n    if (cfg.lowestLevel !== undefined) {\n      logger.lowestLevel = cfg.lowestLevel;\n    }\n    for (const filterId of cfg.filters ?? []) {\n      const filter = config.filters?.[filterId];\n      if (filter === undefined) {\n        throw new ConfigError(`Filter not found: ${filterId}.`);\n      }\n      logger.filters.push(toFilter(filter));\n    }\n    strongRefs.add(logger);\n  }\n\n  LoggerImpl.getLogger().contextLocalStorage = config.contextLocalStorage;\n\n  for (const sink of Object.values<Sink>(config.sinks)) {\n    if (Symbol.asyncDispose in sink) {\n      if (allowAsync) asyncDisposables.add(sink as AsyncDisposable);\n      else {\n        throw new ConfigError(\n          \"Async disposables cannot be used with configureSync().\",\n        );\n      }\n    }\n    if (Symbol.dispose in sink) disposables.add(sink as Disposable);\n  }\n\n  for (const filter of Object.values<FilterLike>(config.filters ?? {})) {\n    if (filter == null || typeof filter === \"string\") continue;\n    if (Symbol.asyncDispose in filter) {\n      if (allowAsync) asyncDisposables.add(filter as AsyncDisposable);\n      else {\n        throw new ConfigError(\n          \"Async disposables cannot be used with configureSync().\",\n        );\n      }\n    }\n    if (Symbol.dispose in filter) disposables.add(filter as Disposable);\n  }\n\n  if (\"process\" in globalThis && !(\"Deno\" in globalThis)) {\n    // deno-lint-ignore no-explicit-any\n    const proc = (globalThis as any).process;\n    if (proc?.on) {\n      proc.on(\"exit\", allowAsync ? dispose : disposeSync);\n    }\n  } else {\n    // @ts-ignore: It's fine to addEventListener() on the browser/Deno\n    addEventListener(\"unload\", allowAsync ? dispose : disposeSync);\n  }\n  const meta = LoggerImpl.getLogger([\"logtape\", \"meta\"]);\n  if (!metaConfigured) {\n    meta.sinks.push(getConsoleSink());\n  }\n\n  meta.info(\n    \"LogTape loggers are configured.  Note that LogTape itself uses the meta \" +\n      \"logger, which has category {metaLoggerCategory}.  The meta logger \" +\n      \"purposes to log internal errors such as sink exceptions.  If you \" +\n      \"are seeing this message, the meta logger is automatically configured.  \" +\n      \"It's recommended to configure the meta logger with a separate sink \" +\n      \"so that you can easily notice if logging itself fails or is \" +\n      \"misconfigured.  To turn off this message, configure the meta logger \" +\n      \"with higher log levels than {dismissLevel}.  See also \" +\n      \"<https://logtape.org/manual/categories#meta-logger>.\",\n    { metaLoggerCategory: [\"logtape\", \"meta\"], dismissLevel: \"info\" },\n  );\n}\n\n/**\n * Get the current configuration, if any.  Otherwise, `null`.\n * @returns The current configuration, if any.  Otherwise, `null`.\n */\nexport function getConfig(): Config<string, string> | null {\n  return currentConfig;\n}\n\n/**\n * Reset the configuration.  Mostly for testing purposes.\n */\nexport async function reset(): Promise<void> {\n  await dispose();\n  resetInternal();\n}\n\n/**\n * Reset the configuration.  Mostly for testing purposes. Will not clear async\n * sinks, only use with sync sinks. Use {@link reset} if you have async sinks.\n * @since 0.9.0\n */\nexport function resetSync(): void {\n  disposeSync();\n  resetInternal();\n}\n\nfunction resetInternal(): void {\n  const rootLogger = LoggerImpl.getLogger([]);\n  rootLogger.resetDescendants();\n  delete rootLogger.contextLocalStorage;\n  strongRefs.clear();\n  currentConfig = null;\n}\n\n/**\n * Dispose of the disposables.\n */\nexport async function dispose(): Promise<void> {\n  disposeSync();\n  const promises: PromiseLike<void>[] = [];\n  for (const disposable of asyncDisposables) {\n    promises.push(disposable[Symbol.asyncDispose]());\n    asyncDisposables.delete(disposable);\n  }\n  await Promise.all(promises);\n}\n\n/**\n * Dispose of the sync disposables. Async disposables will be untouched,\n * use {@link dispose} if you have async sinks.\n * @since 0.9.0\n */\nexport function disposeSync(): void {\n  for (const disposable of disposables) disposable[Symbol.dispose]();\n  disposables.clear();\n}\n\n/**\n * A configuration error.\n */\nexport class ConfigError extends Error {\n  /**\n   * Constructs a new configuration error.\n   * @param message The error message.\n   */\n  constructor(message: string) {\n    super(message);\n    this.name = \"ConfigureError\";\n  }\n}\n", "// deno-lint-ignore-file no-process-global\n/// <reference types=\"@types/node\" />\n/**\n * @fileoverview\n * Terminal detection and width calculation utilities\n *\n * Provides cross-runtime compatible functions to detect if the process\n * is attached to a terminal and get the terminal width.\n */\n\n/**\n * Detect if the current process is attached to a terminal (TTY).\n *\n * @returns True if stdout is connected to a terminal\n */\nexport function isTerminal(): boolean {\n  try {\n    // Deno runtime\n    if (typeof Deno !== \"undefined\") {\n      // Use modern Deno API\n      if (Deno.stdout.isTerminal) {\n        return Deno.stdout.isTerminal();\n      }\n    }\n\n    // Node.js/Bun runtime\n    if (typeof process !== \"undefined\" && process.stdout) {\n      return Boolean(process.stdout.isTTY);\n    }\n\n    // Browser environment - never a terminal\n    if (typeof window !== \"undefined\") {\n      return false;\n    }\n\n    // Unknown environment - assume not a terminal\n    return false;\n  } catch {\n    // If any detection method fails, assume not a terminal\n    return false;\n  }\n}\n\n/**\n * Get the current terminal width in columns.\n *\n * @returns Terminal width in columns, or null if not available\n */\nexport function getTerminalWidth(): number | null {\n  try {\n    // Deno runtime\n    if (typeof Deno !== \"undefined\") {\n      // Try to get console size\n      if (Deno.consoleSize) {\n        const size = Deno.consoleSize();\n        return size?.columns || null;\n      }\n    }\n\n    // Node.js/Bun runtime\n    if (typeof process !== \"undefined\" && process.stdout) {\n      return process.stdout.columns || null;\n    }\n\n    // Fallback to environment variable\n    const envColumns = typeof Deno !== \"undefined\"\n      ? Deno.env.get(\"COLUMNS\")\n      : process?.env?.COLUMNS;\n\n    if (envColumns) {\n      const parsed = parseInt(envColumns, 10);\n      return isNaN(parsed) ? null : parsed;\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get the optimal word wrap width based on terminal detection.\n *\n * @param defaultWidth Default width to use when not in a terminal\n * @returns The optimal width\n */\nexport function getOptimalWordWrapWidth(defaultWidth: number = 80): number {\n  if (!isTerminal()) {\n    return defaultWidth;\n  }\n\n  const terminalWidth = getTerminalWidth();\n  return terminalWidth || defaultWidth;\n}\n", "/**\n * Truncation strategies for category names.\n *\n * @since 1.0.0\n */\nexport type TruncationStrategy = \"middle\" | \"end\" | false;\n\n/**\n * Truncates a category array to fit within a maximum width using the specified strategy.\n *\n * This function intelligently shortens long hierarchical category names while\n * preserving important context. The truncation behavior depends on the chosen\n * strategy:\n *\n * - `\"middle\"`: Keeps the first and last segments with \"\" in between\n * - `\"end\"`: Truncates at the end with \"\" suffix\n * - `false`: No truncation (returns full category string)\n *\n * When the category is too long even for middle truncation (first + \"\" + last\n * exceeds maxWidth), it falls back to end truncation.\n *\n * @param category The category segments to truncate.\n * @param maxWidth Maximum width for the category string.\n * @param separator Category separator (default: \".\").\n * @param strategy Truncation strategy to use (default: \"middle\").\n * @returns The truncated category string.\n *\n * @example\n * ```typescript\n * // Middle truncation\n * truncateCategory([\"app\", \"server\", \"http\", \"auth\"], 15, \".\", \"middle\");\n * // Returns: \"appauth\"\n *\n * // End truncation\n * truncateCategory([\"app\", \"server\", \"http\", \"auth\"], 15, \".\", \"end\");\n * // Returns: \"app.server.h\"\n *\n * // No truncation\n * truncateCategory([\"app\", \"auth\"], 20, \".\", false);\n * // Returns: \"app.auth\"\n * ```\n *\n * @since 1.0.0\n */\nexport function truncateCategory(\n  category: readonly string[],\n  maxWidth: number,\n  separator: string = \".\",\n  strategy: TruncationStrategy = \"middle\",\n): string {\n  if (!strategy || maxWidth <= 0) {\n    return category.join(separator);\n  }\n\n  const full = category.join(separator);\n  if (full.length <= maxWidth) {\n    return full;\n  }\n\n  // Minimum width needed for truncation with ellipsis\n  const minWidth = 5; // e.g., \"az\"\n  if (maxWidth < minWidth) {\n    return \"\";\n  }\n\n  if (strategy === \"end\") {\n    return full.substring(0, maxWidth - 1) + \"\";\n  }\n\n  // Middle truncation strategy\n  if (category.length <= 2) {\n    // For short categories, just truncate the end\n    return full.substring(0, maxWidth - 1) + \"\";\n  }\n\n  // Try to keep first and last segments\n  const first = category[0];\n  const last = category[category.length - 1];\n  const ellipsis = \"\";\n\n  // Check if we can at least fit firstlast\n  const minimalLength = first.length + ellipsis.length + last.length;\n  if (minimalLength > maxWidth) {\n    // Even minimal format is too long, fallback to end truncation\n    return full.substring(0, maxWidth - 1) + \"\";\n  }\n\n  // For simple case with limited space, just do firstlast\n  return `${first}${ellipsis}${last}`;\n}\n", "/**\n * @fileoverview\n * wcwidth implementation for JavaScript/TypeScript\n *\n * This module provides functions to calculate the display width of Unicode\n * characters and strings in terminal/monospace contexts, compatible with\n * the Python wcwidth library and POSIX wcwidth() standard.\n *\n * Based on Unicode 15.1.0 character width tables.\n */\n\n// Pre-compiled regex for ANSI escape sequences\n// deno-lint-ignore no-control-regex\nconst ANSI_PATTERN = /\\x1b\\[[0-9;]*m/g;\n\n/**\n * Remove all ANSI escape sequences from a string.\n *\n * @param text The string to clean\n * @returns String with ANSI escape sequences removed\n */\nexport function stripAnsi(text: string): string {\n  return text.replace(ANSI_PATTERN, \"\");\n}\n\n/**\n * Calculate the display width of a string, ignoring ANSI escape codes\n * and accounting for Unicode character widths using wcwidth-compatible logic.\n *\n * @param text The string to measure\n * @returns The display width in terminal columns\n */\nexport function getDisplayWidth(text: string): number {\n  // Remove all ANSI escape sequences first\n  const cleanText = stripAnsi(text);\n\n  if (cleanText.length === 0) return 0;\n\n  let width = 0;\n  let i = 0;\n\n  // Process character by character, handling surrogate pairs and combining characters\n  while (i < cleanText.length) {\n    const code = cleanText.codePointAt(i);\n    if (code === undefined) {\n      i++;\n      continue;\n    }\n\n    const charWidth = wcwidth(code);\n    if (charWidth >= 0) {\n      width += charWidth;\n    }\n\n    // Move to next code point (handles surrogate pairs)\n    i += (code > 0xFFFF) ? 2 : 1;\n  }\n\n  return width;\n}\n\n/**\n * Get the display width of a single Unicode code point.\n * Based on wcwidth implementation - returns:\n * -1: Non-printable/control character\n *  0: Zero-width character (combining marks, etc.)\n *  1: Normal width character\n *  2: Wide character (East Asian, emoji, etc.)\n *\n * @param code Unicode code point\n * @returns Display width (-1, 0, 1, or 2)\n */\nexport function wcwidth(code: number): number {\n  // C0 and C1 control characters\n  if (code < 32 || (code >= 0x7F && code < 0xA0)) {\n    return -1;\n  }\n\n  // Zero-width characters (based on wcwidth table_zero.py)\n  if (isZeroWidth(code)) {\n    return 0;\n  }\n\n  // Wide characters (based on wcwidth table_wide.py)\n  if (isWideCharacter(code)) {\n    return 2;\n  }\n\n  return 1;\n}\n\n// Zero-width character ranges (sorted for binary search)\nconst ZERO_WIDTH_RANGES: Array<[number, number]> = [\n  [0x0300, 0x036F], // Combining Diacritical Marks\n  [0x0483, 0x0489], // Hebrew combining marks\n  [0x0591, 0x05BD], // Arabic combining marks\n  [0x05C1, 0x05C2],\n  [0x05C4, 0x05C5],\n  [0x0610, 0x061A], // More Arabic combining marks\n  [0x064B, 0x065F],\n  [0x06D6, 0x06DC],\n  [0x06DF, 0x06E4],\n  [0x06E7, 0x06E8],\n  [0x06EA, 0x06ED],\n  [0x0730, 0x074A],\n  [0x07A6, 0x07B0],\n  [0x07EB, 0x07F3],\n  [0x0816, 0x0819],\n  [0x081B, 0x0823],\n  [0x0825, 0x0827],\n  [0x0829, 0x082D],\n  [0x0859, 0x085B],\n  [0x08D3, 0x08E1],\n  [0x08E3, 0x0902],\n  [0x0941, 0x0948],\n  [0x0951, 0x0957],\n  [0x0962, 0x0963],\n  [0x09C1, 0x09C4],\n  [0x09E2, 0x09E3],\n  [0x0A01, 0x0A02],\n  [0x0A41, 0x0A42],\n  [0x0A47, 0x0A48],\n  [0x0A4B, 0x0A4D],\n  [0x0A70, 0x0A71],\n  [0x0A81, 0x0A82],\n  [0x0AC1, 0x0AC5],\n  [0x0AC7, 0x0AC8],\n  [0x0AE2, 0x0AE3],\n  [0x0AFA, 0x0AFF],\n  [0x0B41, 0x0B44],\n  [0x0B55, 0x0B56],\n  [0x0B62, 0x0B63],\n  [0x0C3E, 0x0C40],\n  [0x0C46, 0x0C48],\n  [0x0C4A, 0x0C4D],\n  [0x0C55, 0x0C56],\n  [0x0C62, 0x0C63],\n  [0x0CCC, 0x0CCD],\n  [0x0CE2, 0x0CE3],\n  [0x0D00, 0x0D01],\n  [0x0D3B, 0x0D3C],\n  [0x0D62, 0x0D63],\n  [0x0DD2, 0x0DD4],\n  [0x0E34, 0x0E3A],\n  [0x0E47, 0x0E4E],\n  [0x0EB4, 0x0EBC],\n  [0x0EC8, 0x0ECD],\n  [0x0F18, 0x0F19],\n  [0x0F71, 0x0F7E],\n  [0x0F80, 0x0F84],\n  [0x0F86, 0x0F87],\n  [0x0F8D, 0x0F97],\n  [0x0F99, 0x0FBC],\n  [0x102D, 0x1030],\n  [0x1032, 0x1037],\n  [0x1039, 0x103A],\n  [0x103D, 0x103E],\n  [0x1058, 0x1059],\n  [0x105E, 0x1060],\n  [0x1071, 0x1074],\n  [0x1085, 0x1086],\n  [0x135D, 0x135F],\n  [0x1712, 0x1714],\n  [0x1732, 0x1734],\n  [0x1752, 0x1753],\n  [0x1772, 0x1773],\n  [0x17B4, 0x17B5],\n  [0x17B7, 0x17BD],\n  [0x17C9, 0x17D3],\n  [0x180B, 0x180D],\n  [0x1885, 0x1886],\n  [0x1920, 0x1922],\n  [0x1927, 0x1928],\n  [0x1939, 0x193B],\n  [0x1A17, 0x1A18],\n  [0x1A58, 0x1A5E],\n  [0x1A65, 0x1A6C],\n  [0x1A73, 0x1A7C],\n  [0x1AB0, 0x1ABE],\n  [0x1B00, 0x1B03],\n  [0x1B36, 0x1B3A],\n  [0x1B6B, 0x1B73],\n  [0x1B80, 0x1B81],\n  [0x1BA2, 0x1BA5],\n  [0x1BA8, 0x1BA9],\n  [0x1BAB, 0x1BAD],\n  [0x1BE8, 0x1BE9],\n  [0x1BEF, 0x1BF1],\n  [0x1C2C, 0x1C33],\n  [0x1C36, 0x1C37],\n  [0x1CD0, 0x1CD2],\n  [0x1CD4, 0x1CE0],\n  [0x1CE2, 0x1CE8],\n  [0x1CF8, 0x1CF9],\n  [0x1DC0, 0x1DF9],\n  [0x1DFB, 0x1DFF],\n  [0x200B, 0x200F], // Zero-width spaces\n  [0x202A, 0x202E], // Bidirectional format characters\n  [0x2060, 0x2064], // Word joiner, etc.\n  [0x2066, 0x206F], // More bidirectional\n  [0xFE00, 0xFE0F], // Variation selectors\n  [0xFE20, 0xFE2F], // Combining half marks\n];\n\n// Single zero-width characters\nconst ZERO_WIDTH_SINGLES = new Set([\n  0x05BF,\n  0x05C7,\n  0x0670,\n  0x0711,\n  0x07FD,\n  0x093A,\n  0x093C,\n  0x094D,\n  0x0981,\n  0x09BC,\n  0x09CD,\n  0x09FE,\n  0x0A3C,\n  0x0A51,\n  0x0A75,\n  0x0ABC,\n  0x0ACD,\n  0x0B01,\n  0x0B3C,\n  0x0B3F,\n  0x0B4D,\n  0x0B82,\n  0x0BC0,\n  0x0BCD,\n  0x0C00,\n  0x0C04,\n  0x0C81,\n  0x0CBC,\n  0x0CBF,\n  0x0CC6,\n  0x0D41,\n  0x0D44,\n  0x0D4D,\n  0x0D81,\n  0x0DCA,\n  0x0DD6,\n  0x0E31,\n  0x0EB1,\n  0x0F35,\n  0x0F37,\n  0x0F39,\n  0x0FC6,\n  0x1082,\n  0x108D,\n  0x109D,\n  0x17C6,\n  0x17DD,\n  0x18A9,\n  0x1932,\n  0x1A1B,\n  0x1A56,\n  0x1A60,\n  0x1A62,\n  0x1A7F,\n  0x1B34,\n  0x1B3C,\n  0x1B42,\n  0x1BE6,\n  0x1BED,\n  0x1CED,\n  0x1CF4,\n  0xFEFF,\n]);\n\n/**\n * Binary search to check if a value is within any range\n */\nfunction isInRanges(code: number, ranges: Array<[number, number]>): boolean {\n  let left = 0;\n  let right = ranges.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const [start, end] = ranges[mid];\n\n    if (code >= start && code <= end) {\n      return true;\n    } else if (code < start) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if a character is zero-width (combining marks, etc.)\n * Based on wcwidth's zero-width table.\n *\n * @param code Unicode code point\n * @returns True if the character has zero display width\n */\nfunction isZeroWidth(code: number): boolean {\n  return ZERO_WIDTH_SINGLES.has(code) || isInRanges(code, ZERO_WIDTH_RANGES);\n}\n\n/**\n * Check if a character code point represents a wide character.\n * Based on wcwidth's wide character table (selected ranges from Unicode 15.1.0).\n *\n * @param code Unicode code point\n * @returns True if the character has width 2\n */\nfunction isWideCharacter(code: number): boolean {\n  // cSpell: disable\n  return (\n    // Based on wcwidth table_wide.py for Unicode 15.1.0\n    (code >= 0x1100 && code <= 0x115F) || // Hangul Jamo\n    (code >= 0x231A && code <= 0x231B) || // Watch, Hourglass\n    (code >= 0x2329 && code <= 0x232A) || // Angle brackets\n    (code >= 0x23E9 && code <= 0x23EC) || // Media controls\n    code === 0x23F0 || code === 0x23F3 || // Alarm clock, hourglass\n    (code >= 0x25FD && code <= 0x25FE) || // Small squares\n    (code >= 0x2614 && code <= 0x2615) || // Umbrella, coffee\n    (code >= 0x2648 && code <= 0x2653) || // Zodiac signs\n    code === 0x267F || code === 0x2693 || // Wheelchair, anchor\n    code === 0x26A0 || code === 0x26A1 || code === 0x26AA || code === 0x26AB || // Warning, lightning, circles\n    (code >= 0x26BD && code <= 0x26BE) || // Sports balls\n    (code >= 0x26C4 && code <= 0x26C5) || // Weather\n    code === 0x26CE || code === 0x26D4 || // Ophiuchus, no entry\n    (code >= 0x26EA && code <= 0x26EA) || // Church\n    (code >= 0x26F2 && code <= 0x26F3) || // Fountain, golf\n    code === 0x26F5 || code === 0x26FA || // Sailboat, tent\n    code === 0x26FD || // Gas pump\n    (code >= 0x2705 && code <= 0x2705) || // Check mark\n    (code >= 0x270A && code <= 0x270B) || // Raised fists\n    code === 0x2728 || // Sparkles ()\n    code === 0x274C || // Cross mark ()\n    code === 0x274E || // Cross mark button\n    (code >= 0x2753 && code <= 0x2755) || // Question marks\n    code === 0x2757 || // Exclamation\n    (code >= 0x2795 && code <= 0x2797) || // Plus signs\n    code === 0x27B0 || code === 0x27BF || // Curly loop, double curly loop\n    (code >= 0x2B1B && code <= 0x2B1C) || // Large squares\n    code === 0x2B50 || code === 0x2B55 || // Star, circle\n    (code >= 0x2E80 && code <= 0x2E99) || // CJK Radicals Supplement\n    (code >= 0x2E9B && code <= 0x2EF3) ||\n    (code >= 0x2F00 && code <= 0x2FD5) || // Kangxi Radicals\n    (code >= 0x2FF0 && code <= 0x2FFB) || // Ideographic Description Characters\n    (code >= 0x3000 && code <= 0x303E) || // CJK Symbols and Punctuation\n    (code >= 0x3041 && code <= 0x3096) || // Hiragana\n    (code >= 0x3099 && code <= 0x30FF) || // Katakana\n    (code >= 0x3105 && code <= 0x312F) || // Bopomofo\n    (code >= 0x3131 && code <= 0x318E) || // Hangul Compatibility Jamo\n    (code >= 0x3190 && code <= 0x31E3) || // Various CJK\n    (code >= 0x31F0 && code <= 0x321E) || // Katakana Phonetic Extensions\n    (code >= 0x3220 && code <= 0x3247) || // Enclosed CJK Letters and Months\n    (code >= 0x3250 && code <= 0x4DBF) || // Various CJK\n    (code >= 0x4E00 && code <= 0x9FFF) || // CJK Unified Ideographs\n    (code >= 0xA960 && code <= 0xA97F) || // Hangul Jamo Extended-A\n    (code >= 0xAC00 && code <= 0xD7A3) || // Hangul Syllables\n    (code >= 0xD7B0 && code <= 0xD7C6) || // Hangul Jamo Extended-B\n    (code >= 0xF900 && code <= 0xFAFF) || // CJK Compatibility Ideographs\n    (code >= 0xFE10 && code <= 0xFE19) || // Vertical Forms\n    (code >= 0xFE30 && code <= 0xFE6F) || // CJK Compatibility Forms\n    (code >= 0xFF00 && code <= 0xFF60) || // Fullwidth Forms\n    (code >= 0xFFE0 && code <= 0xFFE6) || // Fullwidth Forms\n    (code >= 0x16FE0 && code <= 0x16FE4) || // Tangut\n    (code >= 0x16FF0 && code <= 0x16FF1) ||\n    (code >= 0x17000 && code <= 0x187F7) || // Tangut\n    (code >= 0x18800 && code <= 0x18CD5) || // Tangut Components\n    (code >= 0x18D00 && code <= 0x18D08) || // Tangut Supplement\n    (code >= 0x1AFF0 && code <= 0x1AFF3) ||\n    (code >= 0x1AFF5 && code <= 0x1AFFB) ||\n    (code >= 0x1AFFD && code <= 0x1AFFE) ||\n    (code >= 0x1B000 && code <= 0x1B122) || // Kana Extended-A/Supplement\n    (code >= 0x1B150 && code <= 0x1B152) ||\n    (code >= 0x1B164 && code <= 0x1B167) ||\n    (code >= 0x1B170 && code <= 0x1B2FB) ||\n    code === 0x1F004 || // Mahjong Red Dragon\n    code === 0x1F0CF || // Playing Card Black Joker\n    (code >= 0x1F18E && code <= 0x1F18E) || // AB Button\n    (code >= 0x1F191 && code <= 0x1F19A) || // Various squared symbols\n    (code >= 0x1F1E6 && code <= 0x1F1FF) || // Regional Indicator Symbols (flags)\n    (code >= 0x1F200 && code <= 0x1F202) || // Squared symbols\n    (code >= 0x1F210 && code <= 0x1F23B) || // Squared CJK\n    (code >= 0x1F240 && code <= 0x1F248) || // Tortoise shell bracketed\n    (code >= 0x1F250 && code <= 0x1F251) || // Circled ideographs\n    (code >= 0x1F260 && code <= 0x1F265) ||\n    (code >= 0x1F300 && code <= 0x1F6D7) || // Large emoji block\n    (code >= 0x1F6E0 && code <= 0x1F6EC) ||\n    (code >= 0x1F6F0 && code <= 0x1F6FC) ||\n    (code >= 0x1F700 && code <= 0x1F773) ||\n    (code >= 0x1F780 && code <= 0x1F7D8) ||\n    (code >= 0x1F7E0 && code <= 0x1F7EB) ||\n    (code >= 0x1F7F0 && code <= 0x1F7F0) ||\n    (code >= 0x1F800 && code <= 0x1F80B) ||\n    (code >= 0x1F810 && code <= 0x1F847) ||\n    (code >= 0x1F850 && code <= 0x1F859) ||\n    (code >= 0x1F860 && code <= 0x1F887) ||\n    (code >= 0x1F890 && code <= 0x1F8AD) ||\n    (code >= 0x1F8B0 && code <= 0x1F8B1) ||\n    (code >= 0x1F900 && code <= 0x1FA53) || // Supplemental symbols and pictographs\n    (code >= 0x1FA60 && code <= 0x1FA6D) ||\n    (code >= 0x1FA70 && code <= 0x1FA7C) ||\n    (code >= 0x1FA80 && code <= 0x1FA88) ||\n    (code >= 0x1FA90 && code <= 0x1FABD) ||\n    (code >= 0x1FABF && code <= 0x1FAC5) ||\n    (code >= 0x1FACE && code <= 0x1FADB) ||\n    (code >= 0x1FAE0 && code <= 0x1FAE8) ||\n    (code >= 0x1FAF0 && code <= 0x1FAF8) ||\n    (code >= 0x20000 && code <= 0x2FFFD) || // CJK Extension B\n    (code >= 0x30000 && code <= 0x3FFFD) // CJK Extension C\n  );\n  // cSpell: enable\n}\n", "/**\n * @fileoverview\n * Word wrapping utilities for terminal output\n *\n * This module provides functions for wrapping text at specified widths\n * while preserving proper indentation and handling Unicode characters\n * correctly.\n */\n\nimport { getDisplayWidth, stripAnsi } from \"./wcwidth.ts\";\n\n/**\n * Wrap text at specified width with proper indentation for continuation lines.\n * Automatically detects the message start position from the first line.\n *\n * @param text The text to wrap (may contain ANSI escape codes)\n * @param maxWidth Maximum width in terminal columns\n * @param messageContent The plain message content (used to find message start)\n * @returns Wrapped text with proper indentation\n */\nexport function wrapText(\n  text: string,\n  maxWidth: number,\n  messageContent: string,\n): string {\n  if (maxWidth <= 0) return text;\n\n  const displayWidth = getDisplayWidth(text);\n  // If text has newlines (multiline interpolated values), always process it\n  // even if it fits within the width\n  if (displayWidth <= maxWidth && !text.includes(\"\\n\")) return text;\n\n  // Find where the message content starts in the first line\n  const firstLineWords = messageContent.split(\" \");\n  const firstWord = firstLineWords[0];\n  const plainText = stripAnsi(text);\n  const messageStartIndex = plainText.indexOf(firstWord);\n\n  // Calculate the display width of the text up to the message start\n  // This is crucial for proper alignment when emojis are present\n  let indentWidth = 0;\n  if (messageStartIndex >= 0) {\n    const prefixText = plainText.slice(0, messageStartIndex);\n    indentWidth = getDisplayWidth(prefixText);\n  }\n  const indent = \" \".repeat(Math.max(0, indentWidth));\n\n  // Check if text contains newlines (from interpolated values like Error objects)\n  if (text.includes(\"\\n\")) {\n    // Split by existing newlines and process each line\n    const lines = text.split(\"\\n\");\n    const wrappedLines: string[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const lineDisplayWidth = getDisplayWidth(line);\n\n      if (lineDisplayWidth <= maxWidth) {\n        // Line doesn't need wrapping, but add indentation if it's not the first line\n        if (i === 0) {\n          wrappedLines.push(line);\n        } else {\n          wrappedLines.push(indent + line);\n        }\n      } else {\n        // Line needs wrapping\n        const wrappedLine = wrapSingleLine(line, maxWidth, indent);\n        if (i === 0) {\n          wrappedLines.push(wrappedLine);\n        } else {\n          // For continuation lines from interpolated values, add proper indentation\n          const subLines = wrappedLine.split(\"\\n\");\n          for (let j = 0; j < subLines.length; j++) {\n            if (j === 0) {\n              wrappedLines.push(indent + subLines[j]);\n            } else {\n              wrappedLines.push(subLines[j]);\n            }\n          }\n        }\n      }\n    }\n\n    return wrappedLines.join(\"\\n\");\n  }\n\n  // Process as a single line since log records should not have newlines in the formatted output\n  return wrapSingleLine(text, maxWidth, indent);\n}\n\n/**\n * Wrap a single line of text (without existing newlines) at word boundaries.\n * Preserves ANSI escape codes and handles Unicode character widths correctly.\n *\n * @param text The text to wrap (single line, may contain ANSI codes)\n * @param maxWidth Maximum width in terminal columns\n * @param indent Indentation string for continuation lines\n * @returns Wrapped text with newlines and proper indentation\n */\nexport function wrapSingleLine(\n  text: string,\n  maxWidth: number,\n  indent: string,\n): string {\n  // Split text into chunks while preserving ANSI codes\n  const lines: string[] = [];\n  let currentLine = \"\";\n  let currentDisplayWidth = 0;\n  let i = 0;\n\n  while (i < text.length) {\n    // Check for ANSI escape sequence\n    if (text[i] === \"\\x1b\" && text[i + 1] === \"[\") {\n      // Find the end of the ANSI sequence\n      let j = i + 2;\n      while (j < text.length && text[j] !== \"m\") {\n        j++;\n      }\n      if (j < text.length) {\n        j++; // Include the 'm'\n        currentLine += text.slice(i, j);\n        i = j;\n        continue;\n      }\n    }\n\n    const char = text[i];\n\n    // Check if adding this character would exceed the width\n    if (currentDisplayWidth >= maxWidth && char !== \" \") {\n      // Try to find a good break point (space) before the current position\n      const breakPoint = currentLine.lastIndexOf(\" \");\n      if (breakPoint > 0) {\n        // Break at the space\n        lines.push(currentLine.slice(0, breakPoint));\n        currentLine = indent + currentLine.slice(breakPoint + 1) + char;\n        currentDisplayWidth = getDisplayWidth(currentLine);\n      } else {\n        // No space found, hard break\n        lines.push(currentLine);\n        currentLine = indent + char;\n        currentDisplayWidth = getDisplayWidth(currentLine);\n      }\n    } else {\n      currentLine += char;\n      // Recalculate display width properly for Unicode characters\n      currentDisplayWidth = getDisplayWidth(currentLine);\n    }\n\n    i++;\n  }\n\n  if (currentLine.trim()) {\n    lines.push(currentLine);\n  }\n\n  // Filter out empty lines (lines with only indentation/spaces)\n  const filteredLines = lines.filter((line) => line.trim().length > 0);\n\n  return filteredLines.join(\"\\n\");\n}\n", "import util from \"node:util\";\n\nexport interface InspectOptions {\n  colors?: boolean;\n  depth?: number | null;\n  compact?: boolean;\n  [key: string]: unknown;\n}\n\nexport function inspect(obj: unknown, options?: InspectOptions): string {\n  return util.inspect(obj, options);\n}\n", "import type {\n  LogLevel,\n  LogRecord,\n  TextFormatter,\n  TextFormatterOptions,\n} from \"@logtape/logtape\";\nimport { inspect } from \"#util\";\nimport { getOptimalWordWrapWidth } from \"./terminal.ts\";\nimport { truncateCategory, type TruncationStrategy } from \"./truncate.ts\";\nimport { getDisplayWidth } from \"./wcwidth.ts\";\nimport { wrapText } from \"./wordwrap.ts\";\n\n/**\n * ANSI escape codes for styling\n */\nconst RESET = \"\\x1b[0m\";\nconst DIM = \"\\x1b[2m\";\n\n// Default true color values (referenced in JSDoc)\nconst defaultColors = {\n  trace: \"rgb(167,139,250)\", // Light purple\n  debug: \"rgb(96,165,250)\", // Light blue\n  info: \"rgb(52,211,153)\", // Emerald\n  warning: \"rgb(251,191,36)\", // Amber\n  error: \"rgb(248,113,113)\", // Light red\n  fatal: \"rgb(220,38,38)\", // Dark red\n  category: \"rgb(100,116,139)\", // Slate\n  message: \"rgb(148,163,184)\", // Light slate\n  timestamp: \"rgb(100,116,139)\", // Slate\n} as const;\n\n/**\n * ANSI style codes\n */\nconst styles = {\n  reset: RESET,\n  bold: \"\\x1b[1m\",\n  dim: DIM,\n  italic: \"\\x1b[3m\",\n  underline: \"\\x1b[4m\",\n  strikethrough: \"\\x1b[9m\",\n} as const;\n\n/**\n * Standard ANSI colors (16-color)\n */\nconst ansiColors = {\n  black: \"\\x1b[30m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n} as const;\n\n/**\n * Color type definition\n */\nexport type Color =\n  | keyof typeof ansiColors\n  | `rgb(${number},${number},${number})`\n  | `#${string}`\n  | null;\n\n/**\n * Category color mapping for prefix-based coloring.\n *\n * Maps category prefixes (as arrays) to colors. The formatter will match\n * categories against these prefixes and use the corresponding color.\n * Longer/more specific prefixes take precedence over shorter ones.\n *\n * @example\n * ```typescript\n * new Map([\n *   [[\"app\", \"auth\"], \"#ff6b6b\"],     // app.auth.* -> red\n *   [[\"app\", \"db\"], \"#4ecdc4\"],       // app.db.* -> teal\n *   [[\"app\"], \"#45b7d1\"],             // app.* (fallback) -> blue\n *   [[\"lib\"], \"#96ceb4\"],             // lib.* -> green\n * ])\n * ```\n */\nexport type CategoryColorMap = Map<readonly string[], Color>;\n\n/**\n * Internal representation of category prefix patterns\n */\ntype CategoryPattern = {\n  prefix: readonly string[];\n  color: Color;\n};\n\n/**\n * Style type definition - supports single styles, arrays of styles, or null\n */\nexport type Style = keyof typeof styles | (keyof typeof styles)[] | null;\n\n// Pre-compiled regex patterns for color parsing\nconst RGB_PATTERN = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/;\nconst HEX_PATTERN = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;\n\n/**\n * Helper function to convert color to ANSI escape code\n */\nfunction colorToAnsi(color: Color): string {\n  if (color === null) return \"\";\n  if (color in ansiColors) {\n    return ansiColors[color as keyof typeof ansiColors];\n  }\n\n  // Handle rgb() format\n  const rgbMatch = color.match(RGB_PATTERN);\n  if (rgbMatch) {\n    const [, r, g, b] = rgbMatch;\n    return `\\x1b[38;2;${r};${g};${b}m`;\n  }\n\n  // Handle hex format (#rrggbb or #rgb)\n  const hexMatch = color.match(HEX_PATTERN);\n  if (hexMatch) {\n    let hex = hexMatch[1];\n    // Convert 3-digit hex to 6-digit\n    if (hex.length === 3) {\n      hex = hex.split(\"\").map((c) => c + c).join(\"\");\n    }\n    const r = parseInt(hex.substr(0, 2), 16);\n    const g = parseInt(hex.substr(2, 2), 16);\n    const b = parseInt(hex.substr(4, 2), 16);\n    return `\\x1b[38;2;${r};${g};${b}m`;\n  }\n\n  return \"\";\n}\n\n/**\n * Helper function to convert style to ANSI escape code\n */\nfunction styleToAnsi(style: Style): string {\n  if (style === null) return \"\";\n  if (Array.isArray(style)) {\n    return style.map((s) => styles[s] || \"\").join(\"\");\n  }\n  return styles[style] || \"\";\n}\n\n/**\n * Converts a category color map to internal patterns and sorts them by specificity.\n * More specific (longer) prefixes come first for proper matching precedence.\n */\nfunction prepareCategoryPatterns(\n  categoryColorMap: CategoryColorMap,\n): CategoryPattern[] {\n  const patterns: CategoryPattern[] = [];\n\n  for (const [prefix, color] of categoryColorMap) {\n    patterns.push({ prefix, color });\n  }\n\n  // Sort by prefix length (descending) for most-specific-first matching\n  return patterns.sort((a, b) => b.prefix.length - a.prefix.length);\n}\n\n/**\n * Matches a category against category color patterns.\n * Returns the color of the first matching pattern, or null if no match.\n */\nfunction matchCategoryColor(\n  category: readonly string[],\n  patterns: CategoryPattern[],\n): Color {\n  for (const pattern of patterns) {\n    if (categoryMatches(category, pattern.prefix)) {\n      return pattern.color;\n    }\n  }\n  return null;\n}\n\n/**\n * Checks if a category matches a prefix pattern.\n * A category matches if it starts with all segments of the prefix.\n */\nfunction categoryMatches(\n  category: readonly string[],\n  prefix: readonly string[],\n): boolean {\n  if (prefix.length > category.length) {\n    return false;\n  }\n\n  for (let i = 0; i < prefix.length; i++) {\n    if (category[i] !== prefix[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Default icons for each log level\n */\nconst defaultIcons: Record<LogLevel, string> = {\n  trace: \"\",\n  debug: \"\",\n  info: \"\",\n  warning: \"\",\n  error: \"\",\n  fatal: \"\",\n};\n\n/**\n * Normalize icon spacing to ensure consistent column alignment.\n *\n * All icons will be padded with spaces to match the width of the widest icon,\n * ensuring consistent prefix alignment across all log levels.\n *\n * @param iconMap The icon mapping to normalize\n * @returns A new icon map with consistent spacing\n */\nfunction normalizeIconSpacing(\n  iconMap: Record<LogLevel, string>,\n): Record<LogLevel, string> {\n  const entries = Object.entries(iconMap) as Array<[LogLevel, string]>;\n  const maxWidth = Math.max(\n    ...entries.map(([, icon]) => getDisplayWidth(icon)),\n  );\n\n  return Object.fromEntries(\n    entries.map(([level, icon]) => [\n      level,\n      icon + \" \".repeat(maxWidth - getDisplayWidth(icon)),\n    ]),\n  ) as Record<LogLevel, string>;\n}\n\n/**\n * Configuration options for the pretty formatter.\n *\n * This interface extends the base text formatter options while providing\n * extensive customization options for visual styling, layout control, and\n * development-focused features. It offers granular control over colors,\n * styles, and formatting similar to the ANSI color formatter.\n *\n * @since 1.0.0\n */\nexport interface PrettyFormatterOptions\n  extends Omit<TextFormatterOptions, \"category\" | \"value\" | \"format\"> {\n  /**\n   * Color for timestamp display when timestamps are enabled.\n   *\n   * Supports true color RGB values, hex colors, or ANSI color names.\n   * Set to `null` to disable timestamp coloring.\n   *\n   * @example\n   * ```typescript\n   * timestampColor: \"#888888\"        // Hex color\n   * timestampColor: \"rgb(128,128,128)\" // RGB color\n   * timestampColor: \"cyan\"           // ANSI color name\n   * timestampColor: null             // No color\n   * ```\n   *\n   * @default `\"rgb(100,116,139)\"` (slate gray)\n   */\n  readonly timestampColor?: Color;\n\n  /**\n   * Visual style applied to timestamp text.\n   *\n   * Controls text appearance like boldness, dimming, etc.\n   * Supports single styles, multiple styles combined, or no styling.\n   * Combines with `timestampColor` for full styling control.\n   *\n   * @example\n   * ```typescript\n   * timestampStyle: \"dim\"                    // Single style: dimmed text\n   * timestampStyle: \"bold\"                   // Single style: bold text\n   * timestampStyle: [\"bold\", \"underline\"]    // Multiple styles: bold + underlined\n   * timestampStyle: [\"dim\", \"italic\"]        // Multiple styles: dimmed + italic\n   * timestampStyle: null                     // No styling\n   * ```\n   *\n   * @default `\"dim\"`\n   */\n  readonly timestampStyle?: Style;\n\n  /**\n   * Custom colors for each log level.\n   *\n   * Allows fine-grained control over level appearance. Each level can have\n   * its own color scheme. Unspecified levels use built-in defaults.\n   * Set individual levels to `null` to disable coloring for that level.\n   *\n   * @example\n   * ```typescript\n   * levelColors: {\n   *   info: \"#00ff00\",     // Bright green for info\n   *   error: \"#ff0000\",    // Bright red for errors\n   *   warning: \"orange\",   // ANSI orange for warnings\n   *   debug: null,         // No color for debug\n   * }\n   * ```\n   *\n   * @default Built-in color scheme (purple trace, blue debug, green info, amber warning, red error, dark red fatal)\n   */\n  readonly levelColors?: Partial<Record<LogLevel, Color>>;\n\n  /**\n   * Visual style applied to log level text.\n   *\n   * Controls the appearance of the level indicator (e.g., \"info\", \"error\").\n   * Supports single styles, multiple styles combined, or no styling.\n   * Applied in addition to level-specific colors.\n   *\n   * @example\n   * ```typescript\n   * levelStyle: \"bold\"                    // Single style: bold level text\n   * levelStyle: \"underline\"               // Single style: underlined level text\n   * levelStyle: [\"bold\", \"underline\"]     // Multiple styles: bold + underlined\n   * levelStyle: [\"dim\", \"italic\"]         // Multiple styles: dimmed + italic\n   * levelStyle: null                      // No additional styling\n   * ```\n   *\n   * @default `\"underline\"`\n   */\n  readonly levelStyle?: Style;\n\n  /**\n   * Icon configuration for each log level.\n   *\n   * Controls the emoji/symbol displayed before each log entry.\n   * Provides visual quick-identification of log severity.\n   *\n   * - `true`: Use built-in emoji set ( trace,  debug,  info,  warning,  error,  fatal)\n   * - `false`: Disable all icons for clean text-only output\n   * - Object: Custom icon mapping, falls back to defaults for unspecified levels\n   *\n   * @example\n   * ```typescript\n   * icons: true                    // Use default emoji set\n   * icons: false                   // No icons\n   * icons: {\n   *   info: \"\",                  // Custom info icon\n   *   error: \"\",                 // Custom error icon\n   *   warning: \"\",               // Custom warning icon\n   * }\n   * ```\n   *\n   * @default `true` (use default emoji icons)\n   */\n  readonly icons?: boolean | Partial<Record<LogLevel, string>>;\n\n  /**\n   * Character(s) used to separate category hierarchy levels.\n   *\n   * Categories are hierarchical (e.g., [\"app\", \"auth\", \"jwt\"]) and this\n   * separator joins them for display (e.g., \"app.auth.jwt\").\n   *\n   * @example\n   * ```typescript\n   * categorySeparator: \"\"        // appauthjwt\n   * categorySeparator: \".\"        // app.auth.jwt\n   * categorySeparator: \":\"        // app:auth:jwt\n   * categorySeparator: \" > \"      // app > auth > jwt\n   * categorySeparator: \"::\"       // app::auth::jwt\n   * ```\n   *\n   * @default `\"\"` (interpunct)\n   */\n  readonly categorySeparator?: string;\n\n  /**\n   * Default color for category display.\n   *\n   * Used as fallback when no specific color is found in `categoryColorMap`.\n   * Controls the visual appearance of the category hierarchy display.\n   *\n   * @example\n   * ```typescript\n   * categoryColor: \"#666666\"        // Gray categories\n   * categoryColor: \"blue\"           // Blue categories\n   * categoryColor: \"rgb(100,150,200)\" // Light blue categories\n   * categoryColor: null             // No coloring\n   * ```\n   *\n   * @default `\"rgb(100,116,139)\"` (slate gray)\n   */\n  readonly categoryColor?: Color;\n\n  /**\n   * Category-specific color mapping based on prefixes.\n   *\n   * Maps category prefixes (as arrays) to colors for visual grouping.\n   * More specific (longer) prefixes take precedence over shorter ones.\n   * If no prefix matches, falls back to the default `categoryColor`.\n   *\n   * @example\n   * ```typescript\n   * new Map([\n   *   [[\"app\", \"auth\"], \"#ff6b6b\"],     // app.auth.* -> red\n   *   [[\"app\", \"db\"], \"#4ecdc4\"],       // app.db.* -> teal\n   *   [[\"app\"], \"#45b7d1\"],             // app.* (fallback) -> blue\n   *   [[\"lib\"], \"#96ceb4\"],             // lib.* -> green\n   * ])\n   * ```\n   */\n  readonly categoryColorMap?: CategoryColorMap;\n\n  /**\n   * Visual style applied to category text.\n   *\n   * Controls the appearance of the category hierarchy display.\n   * Supports single styles, multiple styles combined, or no styling.\n   * Applied in addition to category colors from `categoryColor` or `categoryColorMap`.\n   *\n   * @example\n   * ```typescript\n   * categoryStyle: \"dim\"                     // Single style: dimmed category text\n   * categoryStyle: \"italic\"                  // Single style: italic category text\n   * categoryStyle: [\"dim\", \"italic\"]         // Multiple styles: dimmed + italic\n   * categoryStyle: [\"bold\", \"underline\"]     // Multiple styles: bold + underlined\n   * categoryStyle: null                      // No additional styling\n   * ```\n   *\n   * @default `[\"dim\", \"italic\"]` (dimmed for subtle appearance)\n   */\n  readonly categoryStyle?: Style;\n\n  /**\n   * Maximum display width for category names.\n   *\n   * Controls layout consistency by limiting category width.\n   * Long categories are truncated according to `categoryTruncate` strategy.\n   *\n   * @default `20`\n   */\n  readonly categoryWidth?: number;\n\n  /**\n   * Strategy for truncating long category names.\n   *\n   * When categories exceed `categoryWidth`, this controls how truncation works.\n   * Smart truncation preserves important context while maintaining layout.\n   *\n   * - `\"middle\"`: Keep first and last parts (e.g., \"app.serverauth.jwt\")\n   * - `\"end\"`: Truncate at the end (e.g., \"app.server.middleware\")\n   * - `false`: No truncation (ignores `categoryWidth`)\n   *\n   * @example\n   * ```typescript\n   * categoryTruncate: \"middle\"   // app.serverjwt (preserves context)\n   * categoryTruncate: \"end\"      // app.server.midd (linear truncation)\n   * categoryTruncate: false      // app.server.middleware.auth.jwt (full)\n   * ```\n   *\n   * @default `\"middle\"` (smart context-preserving truncation)\n   */\n  readonly categoryTruncate?: TruncationStrategy;\n\n  /**\n   * Color for log message text content.\n   *\n   * Controls the visual appearance of the actual log message content.\n   * Does not affect structured values, which use syntax highlighting.\n   *\n   * @example\n   * ```typescript\n   * messageColor: \"#ffffff\"        // White message text\n   * messageColor: \"green\"          // Green message text\n   * messageColor: \"rgb(200,200,200)\" // Light gray message text\n   * messageColor: null             // No coloring\n   * ```\n   *\n   * @default `\"rgb(148,163,184)\"` (light slate gray)\n   */\n  readonly messageColor?: Color;\n\n  /**\n   * Visual style applied to log message text.\n   *\n   * Controls the appearance of the log message content.\n   * Supports single styles, multiple styles combined, or no styling.\n   * Applied in addition to `messageColor`.\n   *\n   * @example\n   * ```typescript\n   * messageStyle: \"dim\"                      // Single style: dimmed message text\n   * messageStyle: \"italic\"                   // Single style: italic message text\n   * messageStyle: [\"dim\", \"italic\"]          // Multiple styles: dimmed + italic\n   * messageStyle: [\"bold\", \"underline\"]      // Multiple styles: bold + underlined\n   * messageStyle: null                       // No additional styling\n   * ```\n   *\n   * @default `\"dim\"` (dimmed for subtle readability)\n   */\n  readonly messageStyle?: Style;\n\n  /**\n   * Global color control for the entire formatter.\n   *\n   * Master switch to enable/disable all color output.\n   * When disabled, produces clean monochrome output suitable for\n   * non-color terminals or when colors are not desired.\n   *\n   * @example\n   * ```typescript\n   * colors: true     // Full color output (default)\n   * colors: false    // Monochrome output only\n   * ```\n   *\n   * @default `true` (colors enabled)\n   */\n  readonly colors?: boolean;\n\n  /**\n   * Column alignment for consistent visual layout.\n   *\n   * When enabled, ensures all log components (icons, levels, categories)\n   * align consistently across multiple log entries, creating a clean\n   * tabular appearance.\n   *\n   * @example\n   * ```typescript\n   * align: true      // Aligned columns (default)\n   * align: false     // Compact, non-aligned output\n   * ```\n   *\n   * @default `true` (alignment enabled)\n   */\n  readonly align?: boolean;\n\n  /**\n   * Configuration for structured value inspection and rendering.\n   *\n   * Controls how objects, arrays, and other complex values are displayed\n   * within log messages. Uses Node.js `util.inspect()` style options.\n   *\n   * @example\n   * ```typescript\n   * inspectOptions: {\n   *   depth: 3,         // Show 3 levels of nesting\n   *   colors: false,    // Disable value syntax highlighting\n   *   compact: true,    // Use compact object display\n   * }\n   * ```\n   *\n   * @default `{}` (use built-in defaults: depth=unlimited, colors=auto, compact=true)\n   */\n  readonly inspectOptions?: {\n    /**\n     * Maximum depth to traverse when inspecting nested objects.\n     * @default Infinity (no depth limit)\n     */\n    readonly depth?: number;\n\n    /**\n     * Whether to use syntax highlighting colors for inspected values.\n     * @default Inherited from global `colors` setting\n     */\n    readonly colors?: boolean;\n\n    /**\n     * Whether to use compact formatting for objects and arrays.\n     * @default `true` (compact formatting)\n     */\n    readonly compact?: boolean;\n  };\n\n  /**\n   * Enable word wrapping for long messages.\n   *\n   * When enabled, long messages will be wrapped at the specified width,\n   * with continuation lines aligned to the message column position.\n   *\n   * - `true`: Auto-detect terminal width when attached to a terminal,\n   *   fallback to 80 columns when not in a terminal or detection fails\n   * - `number`: Use the specified width in columns\n   * - `false`: Disable word wrapping\n   *\n   * @example\n   * ```typescript\n   * // Auto-detect terminal width (recommended)\n   * wordWrap: true\n   *\n   * // Custom wrap width\n   * wordWrap: 120\n   *\n   * // Disable word wrapping (default)\n   * wordWrap: false\n   * ```\n   *\n   * @default `true` (auto-detect terminal width)\n   * @since 1.0.0\n   */\n  readonly wordWrap?: boolean | number;\n}\n\n/**\n * Creates a beautiful console formatter optimized for local development.\n *\n * This formatter provides a Signale-inspired visual design with colorful icons,\n * smart category truncation, dimmed styling, and perfect column alignment.\n * It's specifically designed for development environments that support true colors\n * and Unicode characters.\n *\n * The formatter features:\n * - Emoji icons for each log level ( trace,  debug,  info, etc.)\n * - True color support with rich color schemes\n * - Intelligent category truncation for long hierarchical categories\n * - Optional timestamp display with multiple formats\n * - Configurable alignment and styling options\n * - Enhanced value rendering with syntax highlighting\n *\n * @param options Configuration options for customizing the formatter behavior.\n * @returns A text formatter function that can be used with LogTape sinks.\n *\n * @example\n * ```typescript\n * import { configure } from \"@logtape/logtape\";\n * import { getConsoleSink } from \"@logtape/logtape/sink\";\n * import { getPrettyFormatter } from \"@logtape/pretty\";\n *\n * await configure({\n *   sinks: {\n *     console: getConsoleSink({\n *       formatter: getPrettyFormatter({\n *         timestamp: \"time\",\n *         categoryWidth: 25,\n *         icons: {\n *           info: \"\",\n *           error: \"\"\n *         }\n *       })\n *     })\n *   }\n * });\n * ```\n *\n * @since 1.0.0\n */\nexport function getPrettyFormatter(\n  options: PrettyFormatterOptions = {},\n): TextFormatter {\n  // Extract options with defaults\n  const {\n    timestamp = \"none\",\n    timestampColor = \"rgb(100,116,139)\",\n    timestampStyle = \"dim\",\n    level: levelFormat = \"full\",\n    levelColors = {},\n    levelStyle = \"underline\",\n    icons = true,\n    categorySeparator = \"\",\n    categoryColor = \"rgb(100,116,139)\",\n    categoryColorMap = new Map(),\n    categoryStyle = [\"dim\", \"italic\"],\n    categoryWidth = 20,\n    categoryTruncate = \"middle\",\n    messageColor = \"rgb(148,163,184)\",\n    messageStyle = \"dim\",\n    colors: useColors = true,\n    align = true,\n    inspectOptions = {},\n    wordWrap = true,\n  } = options;\n\n  // Resolve icons\n  const baseIconMap: Record<LogLevel, string> = icons === false\n    ? { trace: \"\", debug: \"\", info: \"\", warning: \"\", error: \"\", fatal: \"\" }\n    : icons === true\n    ? defaultIcons\n    : { ...defaultIcons, ...(icons as Partial<Record<LogLevel, string>>) };\n\n  // Normalize icon spacing for consistent alignment\n  const iconMap = normalizeIconSpacing(baseIconMap);\n\n  // Resolve level colors with defaults\n  const resolvedLevelColors: Record<LogLevel, Color> = {\n    trace: defaultColors.trace,\n    debug: defaultColors.debug,\n    info: defaultColors.info,\n    warning: defaultColors.warning,\n    error: defaultColors.error,\n    fatal: defaultColors.fatal,\n    ...levelColors,\n  };\n\n  // Level formatter function with optimized mappings\n  const levelMappings: Record<string, Record<LogLevel, string>> = {\n    \"ABBR\": {\n      trace: \"TRC\",\n      debug: \"DBG\",\n      info: \"INF\",\n      warning: \"WRN\",\n      error: \"ERR\",\n      fatal: \"FTL\",\n    },\n    \"L\": {\n      trace: \"T\",\n      debug: \"D\",\n      info: \"I\",\n      warning: \"W\",\n      error: \"E\",\n      fatal: \"F\",\n    },\n    \"abbr\": {\n      trace: \"trc\",\n      debug: \"dbg\",\n      info: \"inf\",\n      warning: \"wrn\",\n      error: \"err\",\n      fatal: \"ftl\",\n    },\n    \"l\": {\n      trace: \"t\",\n      debug: \"d\",\n      info: \"i\",\n      warning: \"w\",\n      error: \"e\",\n      fatal: \"f\",\n    },\n  };\n\n  const formatLevel = (level: LogLevel): string => {\n    if (typeof levelFormat === \"function\") {\n      return levelFormat(level);\n    }\n\n    if (levelFormat === \"FULL\") return level.toUpperCase();\n    if (levelFormat === \"full\") return level;\n\n    return levelMappings[levelFormat]?.[level] ?? level;\n  };\n\n  // Timestamp formatters lookup table\n  const timestampFormatters: Record<string, (ts: number) => string> = {\n    \"date-time-timezone\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(\"T\", \" \").replace(\"Z\", \" +00:00\");\n    },\n    \"date-time-tz\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(\"T\", \" \").replace(\"Z\", \" +00\");\n    },\n    \"date-time\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(\"T\", \" \").replace(\"Z\", \"\");\n    },\n    \"time-timezone\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(/.*T/, \"\").replace(\"Z\", \" +00:00\");\n    },\n    \"time-tz\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(/.*T/, \"\").replace(\"Z\", \" +00\");\n    },\n    \"time\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(/.*T/, \"\").replace(\"Z\", \"\");\n    },\n    \"date\": (ts) => new Date(ts).toISOString().replace(/T.*/, \"\"),\n    \"rfc3339\": (ts) => new Date(ts).toISOString(),\n  };\n\n  // Resolve timestamp formatter\n  let timestampFn: ((ts: number) => string | null) | null = null;\n  if (timestamp === \"none\" || timestamp === \"disabled\") {\n    timestampFn = null;\n  } else if (typeof timestamp === \"function\") {\n    timestampFn = timestamp;\n  } else {\n    timestampFn = timestampFormatters[timestamp as string] ?? null;\n  }\n\n  // Configure word wrap settings\n  const wordWrapEnabled = wordWrap !== false;\n  let wordWrapWidth: number;\n\n  if (typeof wordWrap === \"number\") {\n    wordWrapWidth = wordWrap;\n  } else if (wordWrap === true) {\n    // Auto-detect terminal width\n    wordWrapWidth = getOptimalWordWrapWidth(80);\n  } else {\n    wordWrapWidth = 80; // Default fallback\n  }\n\n  // Prepare category color patterns for matching\n  const categoryPatterns = prepareCategoryPatterns(categoryColorMap);\n\n  // Calculate level width based on format\n  const allLevels: LogLevel[] = [\n    \"trace\",\n    \"debug\",\n    \"info\",\n    \"warning\",\n    \"error\",\n    \"fatal\",\n  ];\n  const levelWidth = Math.max(...allLevels.map((l) => formatLevel(l).length));\n\n  return (record: LogRecord): string => {\n    // Calculate the prefix parts first to determine message column position\n    const icon = iconMap[record.level] || \"\";\n    const level = formatLevel(record.level);\n    const categoryStr = truncateCategory(\n      record.category,\n      categoryWidth,\n      categorySeparator,\n      categoryTruncate,\n    );\n\n    // Format message with values - handle color reset/reapply for interpolated values\n    let message = \"\";\n    const messageColorCode = useColors ? colorToAnsi(messageColor) : \"\";\n    const messageStyleCode = useColors ? styleToAnsi(messageStyle) : \"\";\n    const messagePrefix = useColors\n      ? `${messageStyleCode}${messageColorCode}`\n      : \"\";\n\n    for (let i = 0; i < record.message.length; i++) {\n      if (i % 2 === 0) {\n        message += record.message[i];\n      } else {\n        const value = record.message[i];\n        const inspected = inspect(value, {\n          colors: useColors,\n          ...inspectOptions,\n        });\n\n        // Handle multiline interpolated values properly\n        if (inspected.includes(\"\\n\")) {\n          const lines = inspected.split(\"\\n\");\n\n          const formattedLines = lines.map((line, index) => {\n            if (index === 0) {\n              // First line: reset formatting, add the line, then reapply\n              if (useColors && (messageColorCode || messageStyleCode)) {\n                return `${RESET}${line}${messagePrefix}`;\n              } else {\n                return line;\n              }\n            } else {\n              // Continuation lines: just apply formatting, let wrapText handle indentation\n              if (useColors && (messageColorCode || messageStyleCode)) {\n                return `${line}${messagePrefix}`;\n              } else {\n                return line;\n              }\n            }\n          });\n          message += formattedLines.join(\"\\n\");\n        } else {\n          // Single line - handle normally\n          if (useColors && (messageColorCode || messageStyleCode)) {\n            message += `${RESET}${inspected}${messagePrefix}`;\n          } else {\n            message += inspected;\n          }\n        }\n      }\n    }\n\n    // Parts are already calculated above\n\n    // Determine category color (with prefix matching)\n    const finalCategoryColor = useColors\n      ? (matchCategoryColor(record.category, categoryPatterns) || categoryColor)\n      : null;\n\n    // Apply colors and styling\n    const formattedIcon = icon;\n    let formattedLevel = level;\n    let formattedCategory = categoryStr;\n    let formattedMessage = message;\n    let formattedTimestamp = \"\";\n\n    if (useColors) {\n      // Apply level color and style\n      const levelColorCode = colorToAnsi(resolvedLevelColors[record.level]);\n      const levelStyleCode = styleToAnsi(levelStyle);\n      formattedLevel = `${levelStyleCode}${levelColorCode}${level}${RESET}`;\n\n      // Apply category color and style (with prefix matching)\n      const categoryColorCode = colorToAnsi(finalCategoryColor);\n      const categoryStyleCode = styleToAnsi(categoryStyle);\n      formattedCategory =\n        `${categoryStyleCode}${categoryColorCode}${categoryStr}${RESET}`;\n\n      // Apply message color and style (already handled in message building above)\n      formattedMessage = `${messagePrefix}${message}${RESET}`;\n    }\n\n    // Format timestamp if needed\n    if (timestampFn) {\n      const ts = timestampFn(record.timestamp);\n      if (ts !== null) {\n        if (useColors) {\n          const timestampColorCode = colorToAnsi(timestampColor);\n          const timestampStyleCode = styleToAnsi(timestampStyle);\n          formattedTimestamp =\n            `${timestampStyleCode}${timestampColorCode}${ts}${RESET}  `;\n        } else {\n          formattedTimestamp = `${ts}  `;\n        }\n      }\n    }\n\n    // Build the final output with alignment\n    if (align) {\n      // Calculate padding accounting for ANSI escape sequences\n      const levelColorLength = useColors\n        ? (colorToAnsi(resolvedLevelColors[record.level]).length +\n          styleToAnsi(levelStyle).length + RESET.length)\n        : 0;\n      const categoryColorLength = useColors\n        ? (colorToAnsi(finalCategoryColor).length +\n          styleToAnsi(categoryStyle).length + RESET.length)\n        : 0;\n\n      const paddedLevel = formattedLevel.padEnd(levelWidth + levelColorLength);\n      const paddedCategory = formattedCategory.padEnd(\n        categoryWidth + categoryColorLength,\n      );\n\n      let result =\n        `${formattedTimestamp}${formattedIcon} ${paddedLevel} ${paddedCategory} ${formattedMessage}`;\n\n      // Apply word wrapping if enabled, or if there are multiline interpolated values\n      if (wordWrapEnabled || message.includes(\"\\n\")) {\n        result = wrapText(\n          result,\n          wordWrapEnabled ? wordWrapWidth : Infinity,\n          message,\n        );\n      }\n\n      return result + \"\\n\";\n    } else {\n      let result =\n        `${formattedTimestamp}${formattedIcon} ${formattedLevel} ${formattedCategory} ${formattedMessage}`;\n\n      // Apply word wrapping if enabled, or if there are multiline interpolated values\n      if (wordWrapEnabled || message.includes(\"\\n\")) {\n        result = wrapText(\n          result,\n          wordWrapEnabled ? wordWrapWidth : Infinity,\n          message,\n        );\n      }\n\n      return result + \"\\n\";\n    }\n  };\n}\n\n/**\n * A pre-configured beautiful console formatter for local development.\n *\n * This is a ready-to-use instance of the pretty formatter with sensible defaults\n * for most development scenarios. It provides immediate visual enhancement to\n * your logs without requiring any configuration.\n *\n * Features enabled by default:\n * - Emoji icons for all log levels\n * - True color support with rich color schemes\n * - Dimmed text styling for better readability\n * - Smart category truncation (20 characters max)\n * - Perfect column alignment\n * - No timestamp display (cleaner for development)\n *\n * For custom configuration, use {@link getPrettyFormatter} instead.\n *\n * @example\n * ```typescript\n * import { configure } from \"@logtape/logtape\";\n * import { getConsoleSink } from \"@logtape/logtape/sink\";\n * import { prettyFormatter } from \"@logtape/pretty\";\n *\n * await configure({\n *   sinks: {\n *     console: getConsoleSink({\n *       formatter: prettyFormatter\n *     })\n *   }\n * });\n * ```\n *\n * @since 1.0.0\n */\nexport const prettyFormatter: TextFormatter = getPrettyFormatter();\n", "/**\n * Unified logging system using LogTape\n *\n * Provides centralized logging configuration with debugMode support.\n * Works across both Deno and Node.js environments with unified import syntax.\n */\n\nimport {\n  configure,\n  getConsoleSink,\n  getLogger,\n  LogLevel,\n} from \"@logtape/logtape\";\nimport { getPrettyFormatter } from \"@logtape/pretty\";\n\nlet isConfigured = false;\n\n/**\n * Initialize the logging system\n * @param debugMode - Whether to enable debug level logging\n */\nexport async function setupLogger(debugMode: boolean): Promise<void> {\n  if (isConfigured) {\n    return; // Avoid double configuration\n  }\n\n  const lowestLevel: LogLevel = debugMode ? \"debug\" : \"info\";\n\n  await configure({\n    sinks: {\n      console: getConsoleSink({\n        formatter: getPrettyFormatter({\n          icons: false, // Remove emoji icons\n          align: false, // Disable column alignment for cleaner output\n          inspectOptions: {\n            depth: Infinity, // Unlimited depth for complex objects\n            colors: true, // Keep syntax highlighting\n            compact: false, // Use readable formatting\n          },\n        }),\n      }),\n    },\n    loggers: [\n      {\n        category: [],\n        lowestLevel,\n        sinks: [\"console\"],\n      },\n      // Suppress LogTape meta logger info messages\n      {\n        category: [\"logtape\", \"meta\"],\n        lowestLevel: \"warning\",\n        sinks: [\"console\"],\n      },\n    ],\n  });\n\n  isConfigured = true;\n}\n\n/**\n * Centralized loggers for different categories\n */\nexport const logger = {\n  // CLI and startup logging\n  cli: getLogger([\"cli\"]),\n\n  // Chat handling and streaming\n  chat: getLogger([\"chat\"]),\n\n  // History and conversation management\n  history: getLogger([\"history\"]),\n\n  // API handlers\n  api: getLogger([\"api\"]),\n\n  // General application logging\n  app: getLogger([\"app\"]),\n};\n\n/**\n * Check if logging system is configured\n */\nexport function isLoggerConfigured(): boolean {\n  return isConfigured;\n}\n", "import { Context } from \"hono\";\nimport type { ProjectInfo, ProjectsResponse } from \"../../shared/types.ts\";\nimport { getEncodedProjectName } from \"../history/pathUtils.ts\";\nimport { logger } from \"../utils/logger.ts\";\nimport { readTextFile } from \"../utils/fs.ts\";\nimport { getHomeDir } from \"../utils/os.ts\";\n\n/**\n * Handles GET /api/projects requests\n * Retrieves list of available project directories from Claude configuration\n * @param c - Hono context object\n * @returns JSON response with projects array\n */\nexport async function handleProjectsRequest(c: Context) {\n  try {\n    const homeDir = getHomeDir();\n    if (!homeDir) {\n      return c.json({ error: \"Home directory not found\" }, 500);\n    }\n\n    const claudeConfigPath = `${homeDir}/.claude.json`;\n\n    try {\n      const configContent = await readTextFile(claudeConfigPath);\n      const config = JSON.parse(configContent);\n\n      if (config.projects && typeof config.projects === \"object\") {\n        const projectPaths = Object.keys(config.projects);\n\n        // Get encoded names for each project, only include projects with history\n        const projects: ProjectInfo[] = [];\n        for (const path of projectPaths) {\n          const encodedName = await getEncodedProjectName(path);\n          // Only include projects that have history directories\n          if (encodedName) {\n            projects.push({\n              path,\n              encodedName,\n            });\n          }\n        }\n\n        const response: ProjectsResponse = { projects };\n        return c.json(response);\n      } else {\n        const response: ProjectsResponse = { projects: [] };\n        return c.json(response);\n      }\n    } catch (error) {\n      // Handle file not found errors in a cross-platform way\n      if (error instanceof Error && error.message.includes(\"No such file\")) {\n        const response: ProjectsResponse = { projects: [] };\n        return c.json(response);\n      }\n      throw error;\n    }\n  } catch (error) {\n    logger.api.error(\"Error reading projects: {error}\", { error });\n    return c.json({ error: \"Failed to read projects\" }, 500);\n  }\n}\n", "/**\n * JSONL file parsing utilities for conversation history\n * Handles reading and parsing Claude conversation history files\n */\n\nimport type {\n  SDKAssistantMessage,\n  SDKUserMessage,\n} from \"@anthropic-ai/claude-code\";\nimport { logger } from \"../utils/logger.ts\";\nimport { readTextFile, readDir } from \"../utils/fs.ts\";\n\n// Raw JSONL line structure from Claude history files\nexport interface RawHistoryLine {\n  type: \"user\" | \"assistant\" | \"system\" | \"result\";\n  message?: SDKUserMessage[\"message\"] | SDKAssistantMessage[\"message\"];\n  sessionId: string;\n  timestamp: string; // ISO string format\n  uuid: string;\n  parentUuid?: string | null;\n  isSidechain?: boolean;\n  userType?: string;\n  cwd?: string;\n  version?: string;\n  requestId?: string;\n}\n\n// Legacy interface maintained for transition period\n// TODO: Remove once all references are updated to use ConversationHistory\nexport interface ConversationFile {\n  sessionId: string;\n  filePath: string;\n  messages: RawHistoryLine[];\n  messageIds: Set<string>;\n  startTime: string;\n  lastTime: string;\n  messageCount: number;\n  lastMessagePreview: string;\n}\n\n/**\n * Parse a single JSONL file and extract conversation data\n * @private - Internal function used by parseAllHistoryFiles\n */\nasync function parseHistoryFile(\n  filePath: string,\n): Promise<ConversationFile | null> {\n  try {\n    const content = await readTextFile(filePath);\n    const lines = content\n      .trim()\n      .split(\"\\n\")\n      .filter((line) => line.trim());\n\n    if (lines.length === 0) {\n      return null; // Empty file\n    }\n\n    const messages: RawHistoryLine[] = [];\n    const messageIds = new Set<string>();\n    let startTime = \"\";\n    let lastTime = \"\";\n    let lastMessagePreview = \"\";\n\n    for (const line of lines) {\n      try {\n        const parsed = JSON.parse(line) as RawHistoryLine;\n        messages.push(parsed);\n\n        // Track message IDs from assistant messages\n        if (parsed.message?.role === \"assistant\" && parsed.message?.id) {\n          messageIds.add(parsed.message.id);\n        }\n\n        // Track timestamps\n        if (!startTime || parsed.timestamp < startTime) {\n          startTime = parsed.timestamp;\n        }\n        if (!lastTime || parsed.timestamp > lastTime) {\n          lastTime = parsed.timestamp;\n        }\n\n        // Extract last message preview (from assistant messages)\n        if (parsed.message?.role === \"assistant\" && parsed.message?.content) {\n          const content = parsed.message.content;\n          if (Array.isArray(content)) {\n            // Handle array format content\n            for (const item of content) {\n              if (typeof item === \"object\" && item && \"text\" in item) {\n                lastMessagePreview = String(item.text).substring(0, 100);\n                break;\n              }\n            }\n          } else if (typeof content === \"string\") {\n            lastMessagePreview = content.substring(0, 100);\n          }\n        }\n      } catch (parseError) {\n        logger.history.error(`Failed to parse line in ${filePath}: {error}`, {\n          error: parseError,\n        });\n        // Continue processing other lines\n      }\n    }\n\n    // Extract session ID from file name (remove .jsonl extension)\n    const fileName = filePath.split(\"/\").pop() || \"\";\n    const sessionId = fileName.replace(\".jsonl\", \"\");\n\n    return {\n      sessionId,\n      filePath,\n      messages,\n      messageIds,\n      startTime,\n      lastTime,\n      messageCount: messages.length,\n      lastMessagePreview: lastMessagePreview || \"No preview available\",\n    };\n  } catch (error) {\n    logger.history.error(`Failed to read history file ${filePath}: {error}`, {\n      error,\n    });\n    return null;\n  }\n}\n\n/**\n * Get all JSONL files in a history directory\n * @private - Internal function used by parseAllHistoryFiles\n */\nasync function getHistoryFiles(historyDir: string): Promise<string[]> {\n  try {\n    const files: string[] = [];\n\n    for await (const entry of readDir(historyDir)) {\n      if (entry.isFile && entry.name.endsWith(\".jsonl\")) {\n        files.push(`${historyDir}/${entry.name}`);\n      }\n    }\n\n    return files;\n  } catch {\n    // Directory doesn't exist or can't be read\n    return [];\n  }\n}\n\n/**\n * Parse all conversation files in a history directory\n * Used by the histories endpoint to get conversation summaries\n */\nexport async function parseAllHistoryFiles(\n  historyDir: string,\n): Promise<ConversationFile[]> {\n  const filePaths = await getHistoryFiles(historyDir);\n  const results: ConversationFile[] = [];\n\n  for (const filePath of filePaths) {\n    const parsed = await parseHistoryFile(filePath);\n    if (parsed) {\n      results.push(parsed);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Check if one set of message IDs is a subset of another\n */\nexport function isSubset<T>(subset: Set<T>, superset: Set<T>): boolean {\n  if (subset.size > superset.size) {\n    return false;\n  }\n\n  for (const item of subset) {\n    if (!superset.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "/**\n * Conversation grouping algorithm\n * Groups conversation files and removes duplicates from continued sessions\n */\n\nimport type { ConversationSummary } from \"../../shared/types.ts\";\nimport type { ConversationFile } from \"./parser.ts\";\nimport { isSubset } from \"./parser.ts\";\n\n/**\n * Group conversations and remove duplicates from continued sessions\n * Based on the algorithm described in docs/histories.md\n */\nexport function groupConversations(\n  conversationFiles: ConversationFile[],\n): ConversationSummary[] {\n  if (conversationFiles.length === 0) {\n    return [];\n  }\n\n  // Sort conversations by message ID set size (ascending)\n  // This ensures we process smaller conversations first\n  const sortedConversations = [...conversationFiles].sort((a, b) => {\n    return a.messageIds.size - b.messageIds.size;\n  });\n\n  // Remove conversations whose message ID sets are subsets of larger ones\n  const uniqueConversations: ConversationFile[] = [];\n\n  for (const currentConv of sortedConversations) {\n    // Check if this conversation's message IDs are a subset of any existing unique conversation\n    const isSubsetOfExisting = uniqueConversations.some((existingConv) =>\n      isSubset(currentConv.messageIds, existingConv.messageIds),\n    );\n\n    if (!isSubsetOfExisting) {\n      // This is either a unique conversation or the \"final\" version of a continued conversation\n      uniqueConversations.push(currentConv);\n    }\n  }\n\n  // Convert to ConversationSummary format and sort by start time (newest first)\n  const summaries = uniqueConversations.map((conv) =>\n    createConversationSummary(conv),\n  );\n\n  // Sort by start time, newest first\n  summaries.sort(\n    (a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\n  );\n\n  return summaries;\n}\n\n/**\n * Create a ConversationSummary from a ConversationFile\n */\nfunction createConversationSummary(\n  conversationFile: ConversationFile,\n): ConversationSummary {\n  return {\n    sessionId: conversationFile.sessionId,\n    startTime: conversationFile.startTime,\n    lastTime: conversationFile.lastTime,\n    messageCount: conversationFile.messageCount,\n    lastMessagePreview: conversationFile.lastMessagePreview,\n  };\n}\n\n/**\n * Debug helper to analyze conversation relationships\n * Useful for understanding how conversations are grouped\n */\nexport function analyzeConversationRelationships(\n  conversationFiles: ConversationFile[],\n): {\n  totalFiles: number;\n  uniqueConversations: number;\n  duplicateFiles: string[];\n  relationships: Array<{\n    file: string;\n    messageIdCount: number;\n    isSubsetOf: string[];\n  }>;\n} {\n  const relationships = conversationFiles.map((conv) => {\n    const isSubsetOf: string[] = [];\n\n    for (const otherConv of conversationFiles) {\n      if (\n        conv.sessionId !== otherConv.sessionId &&\n        isSubset(conv.messageIds, otherConv.messageIds)\n      ) {\n        isSubsetOf.push(otherConv.sessionId);\n      }\n    }\n\n    return {\n      file: conv.sessionId,\n      messageIdCount: conv.messageIds.size,\n      isSubsetOf,\n    };\n  });\n\n  const duplicateFiles = relationships\n    .filter((rel) => rel.isSubsetOf.length > 0)\n    .map((rel) => rel.file);\n\n  const uniqueConversations = conversationFiles.length - duplicateFiles.length;\n\n  return {\n    totalFiles: conversationFiles.length,\n    uniqueConversations,\n    duplicateFiles,\n    relationships,\n  };\n}\n", "import { Context } from \"hono\";\nimport type { HistoryListResponse } from \"../../shared/types.ts\";\nimport { validateEncodedProjectName } from \"../history/pathUtils.ts\";\nimport { parseAllHistoryFiles } from \"../history/parser.ts\";\nimport { groupConversations } from \"../history/grouping.ts\";\nimport { logger } from \"../utils/logger.ts\";\nimport { stat } from \"../utils/fs.ts\";\nimport { getHomeDir } from \"../utils/os.ts\";\n\n/**\n * Handles GET /api/projects/:encodedProjectName/histories requests\n * Fetches conversation history list for a specific project\n * @param c - Hono context object with config variables\n * @returns JSON response with conversation history list\n */\nexport async function handleHistoriesRequest(c: Context) {\n  try {\n    const encodedProjectName = c.req.param(\"encodedProjectName\");\n\n    if (!encodedProjectName) {\n      return c.json({ error: \"Encoded project name is required\" }, 400);\n    }\n\n    if (!validateEncodedProjectName(encodedProjectName)) {\n      return c.json({ error: \"Invalid encoded project name\" }, 400);\n    }\n\n    logger.history.debug(\n      `Fetching histories for encoded project: ${encodedProjectName}`,\n    );\n\n    // Get home directory\n    const homeDir = getHomeDir();\n    if (!homeDir) {\n      return c.json({ error: \"Home directory not found\" }, 500);\n    }\n\n    // Build history directory path directly from encoded name\n    const historyDir = `${homeDir}/.claude/projects/${encodedProjectName}`;\n\n    logger.history.debug(`History directory: ${historyDir}`);\n\n    // Check if the directory exists\n    try {\n      const dirInfo = await stat(historyDir);\n      if (!dirInfo.isDirectory) {\n        return c.json({ error: \"Project not found\" }, 404);\n      }\n    } catch (error) {\n      // Handle file not found errors in a cross-platform way\n      if (error instanceof Error && error.message.includes(\"No such file\")) {\n        return c.json({ error: \"Project not found\" }, 404);\n      }\n      throw error;\n    }\n\n    const conversationFiles = await parseAllHistoryFiles(historyDir);\n\n    logger.history.debug(\n      `Found ${conversationFiles.length} conversation files`,\n    );\n\n    // Group conversations and remove duplicates\n    const conversations = groupConversations(conversationFiles);\n\n    logger.history.debug(\n      `After grouping: ${conversations.length} unique conversations`,\n    );\n\n    const response: HistoryListResponse = {\n      conversations,\n    };\n\n    return c.json(response);\n  } catch (error) {\n    logger.history.error(\"Error fetching conversation histories: {error}\", {\n      error,\n    });\n\n    return c.json(\n      {\n        error: \"Failed to fetch conversation histories\",\n        details: error instanceof Error ? error.message : String(error),\n      },\n      500,\n    );\n  }\n}\n", "/**\n * Timestamp restoration utilities\n * Handles restoring accurate timestamps for continued conversations\n */\n\nimport type { RawHistoryLine } from \"./parser.ts\";\n\n/**\n * Restore accurate timestamps for messages in a conversation\n * When conversations are continued, timestamps get overwritten\n * This function restores original timestamps from first occurrence of each message.id\n */\nexport function restoreTimestamps(\n  messages: RawHistoryLine[],\n): RawHistoryLine[] {\n  // Create a map to track the earliest timestamp for each message ID\n  const timestampMap = new Map<string, string>();\n\n  // First pass: collect earliest timestamps for each message.id\n  for (const msg of messages) {\n    if (msg.type === \"assistant\" && msg.message?.id) {\n      const messageId = msg.message.id;\n      if (!timestampMap.has(messageId)) {\n        timestampMap.set(messageId, msg.timestamp);\n      } else {\n        // Keep the earliest timestamp\n        const existingTimestamp = timestampMap.get(messageId)!;\n        if (msg.timestamp < existingTimestamp) {\n          timestampMap.set(messageId, msg.timestamp);\n        }\n      }\n    }\n  }\n\n  // Second pass: restore timestamps and return updated messages\n  return messages.map((msg) => {\n    if (msg.type === \"assistant\" && msg.message?.id) {\n      const restoredTimestamp = timestampMap.get(msg.message.id);\n      if (restoredTimestamp) {\n        return {\n          ...msg,\n          timestamp: restoredTimestamp,\n        };\n      }\n    }\n    // For user messages and messages without IDs, keep original timestamp\n    return msg;\n  });\n}\n\n/**\n * Sort messages by timestamp (chronological order)\n */\nexport function sortMessagesByTimestamp(\n  messages: RawHistoryLine[],\n): RawHistoryLine[] {\n  return [...messages].sort((a, b) => {\n    return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();\n  });\n}\n\n/**\n * Calculate conversation metadata from messages\n */\nexport function calculateConversationMetadata(messages: RawHistoryLine[]): {\n  startTime: string;\n  endTime: string;\n  messageCount: number;\n} {\n  if (messages.length === 0) {\n    const now = new Date().toISOString();\n    return {\n      startTime: now,\n      endTime: now,\n      messageCount: 0,\n    };\n  }\n\n  // Sort messages by timestamp to get accurate start/end times\n  const sortedMessages = sortMessagesByTimestamp(messages);\n  const startTime = sortedMessages[0].timestamp;\n  const endTime = sortedMessages[sortedMessages.length - 1].timestamp;\n\n  return {\n    startTime,\n    endTime,\n    messageCount: messages.length,\n  };\n}\n\n/**\n * Process messages with timestamp restoration and sorting\n * This is the main function to call for preparing messages for API response\n */\nexport function processConversationMessages(\n  messages: RawHistoryLine[],\n  _sessionId: string,\n): {\n  messages: unknown[];\n  metadata: {\n    startTime: string;\n    endTime: string;\n    messageCount: number;\n  };\n} {\n  // Restore timestamps\n  const restoredMessages = restoreTimestamps(messages);\n\n  // Sort by timestamp\n  const sortedMessages = sortMessagesByTimestamp(restoredMessages);\n\n  // Calculate metadata\n  const metadata = calculateConversationMetadata(sortedMessages);\n\n  // Return as unknown[] for frontend compatibility\n  return {\n    messages: sortedMessages as unknown[],\n    metadata,\n  };\n}\n", "/**\n * Individual conversation loading utilities\n * Handles loading and parsing specific conversation files\n */\n\nimport type { RawHistoryLine } from \"./parser.ts\";\nimport type { ConversationHistory } from \"../../shared/types.ts\";\nimport { logger } from \"../utils/logger.ts\";\nimport { processConversationMessages } from \"./timestampRestore.ts\";\nimport { validateEncodedProjectName } from \"./pathUtils.ts\";\nimport { readTextFile, exists } from \"../utils/fs.ts\";\nimport { getHomeDir } from \"../utils/os.ts\";\n\n/**\n * Load a specific conversation by session ID\n */\nexport async function loadConversation(\n  encodedProjectName: string,\n  sessionId: string,\n): Promise<ConversationHistory | null> {\n  // Validate inputs\n  if (!validateEncodedProjectName(encodedProjectName)) {\n    throw new Error(\"Invalid encoded project name\");\n  }\n\n  if (!validateSessionId(sessionId)) {\n    throw new Error(\"Invalid session ID format\");\n  }\n\n  // Get home directory\n  const homeDir = getHomeDir();\n  if (!homeDir) {\n    throw new Error(\"Home directory not found\");\n  }\n\n  // Build file path\n  const historyDir = `${homeDir}/.claude/projects/${encodedProjectName}`;\n  const filePath = `${historyDir}/${sessionId}.jsonl`;\n\n  // Check if file exists before trying to read it\n  if (!(await exists(filePath))) {\n    return null; // Session not found\n  }\n\n  try {\n    const conversationHistory = await parseConversationFile(\n      filePath,\n      sessionId,\n    );\n    return conversationHistory;\n  } catch (error) {\n    throw error; // Re-throw any parsing errors\n  }\n}\n\n/**\n * Parse a specific conversation file\n * Converts JSONL lines to timestamped SDK messages\n */\nasync function parseConversationFile(\n  filePath: string,\n  sessionId: string,\n): Promise<ConversationHistory> {\n  const content = await readTextFile(filePath);\n  const lines = content\n    .trim()\n    .split(\"\\n\")\n    .filter((line) => line.trim());\n\n  if (lines.length === 0) {\n    throw new Error(\"Empty conversation file\");\n  }\n\n  const rawLines: RawHistoryLine[] = [];\n\n  for (const line of lines) {\n    try {\n      const parsed = JSON.parse(line) as RawHistoryLine;\n      rawLines.push(parsed);\n    } catch (parseError) {\n      logger.history.error(`Failed to parse line in ${filePath}: {error}`, {\n        error: parseError,\n      });\n      // Continue processing other lines\n    }\n  }\n\n  // Process messages (restore timestamps, sort, etc.)\n  const { messages: processedMessages, metadata } = processConversationMessages(\n    rawLines,\n    sessionId,\n  );\n\n  return {\n    sessionId,\n    messages: processedMessages,\n    metadata,\n  };\n}\n\n/**\n * Validate session ID format\n * Should be a valid filename without dangerous characters\n */\nfunction validateSessionId(sessionId: string): boolean {\n  // Should not be empty\n  if (!sessionId) {\n    return false;\n  }\n\n  // Should not contain dangerous characters for filenames\n  // deno-lint-ignore no-control-regex\n  const dangerousChars = /[<>:\"|?*\\x00-\\x1f\\/\\\\]/;\n  if (dangerousChars.test(sessionId)) {\n    return false;\n  }\n\n  // Should not be too long (reasonable filename length)\n  if (sessionId.length > 255) {\n    return false;\n  }\n\n  // Should not start with dots (hidden files)\n  if (sessionId.startsWith(\".\")) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Check if a conversation exists without loading it\n */\nexport async function conversationExists(\n  encodedProjectName: string,\n  sessionId: string,\n): Promise<boolean> {\n  try {\n    const conversation = await loadConversation(encodedProjectName, sessionId);\n    return conversation !== null;\n  } catch {\n    return false;\n  }\n}\n", "import { Context } from \"hono\";\nimport { validateEncodedProjectName } from \"../history/pathUtils.ts\";\nimport { loadConversation } from \"../history/conversationLoader.ts\";\nimport { logger } from \"../utils/logger.ts\";\n\n/**\n * Handles GET /api/projects/:encodedProjectName/histories/:sessionId requests\n * Retrieves detailed conversation history for a specific session\n * @param c - Hono context object with config variables\n * @returns JSON response with conversation details\n */\nexport async function handleConversationRequest(c: Context) {\n  try {\n    const encodedProjectName = c.req.param(\"encodedProjectName\");\n    const sessionId = c.req.param(\"sessionId\");\n\n    if (!encodedProjectName) {\n      return c.json({ error: \"Encoded project name is required\" }, 400);\n    }\n\n    if (!sessionId) {\n      return c.json({ error: \"Session ID is required\" }, 400);\n    }\n\n    if (!validateEncodedProjectName(encodedProjectName)) {\n      return c.json({ error: \"Invalid encoded project name\" }, 400);\n    }\n\n    logger.history.debug(\n      `Fetching conversation details for project: ${encodedProjectName}, session: ${sessionId}`,\n    );\n\n    // Load the specific conversation (already returns processed ConversationHistory)\n    const conversationHistory = await loadConversation(\n      encodedProjectName,\n      sessionId,\n    );\n\n    if (!conversationHistory) {\n      return c.json(\n        {\n          error: \"Conversation not found\",\n          sessionId,\n        },\n        404,\n      );\n    }\n\n    logger.history.debug(\n      `Loaded conversation with ${conversationHistory.messages.length} messages`,\n    );\n\n    return c.json(conversationHistory);\n  } catch (error) {\n    logger.history.error(\"Error fetching conversation details: {error}\", {\n      error,\n    });\n\n    // Handle specific error types\n    if (error instanceof Error) {\n      if (error.message.includes(\"Invalid session ID\")) {\n        return c.json(\n          {\n            error: \"Invalid session ID format\",\n            details: error.message,\n          },\n          400,\n        );\n      }\n\n      if (error.message.includes(\"Invalid encoded project name\")) {\n        return c.json(\n          {\n            error: \"Invalid project name\",\n            details: error.message,\n          },\n          400,\n        );\n      }\n    }\n\n    return c.json(\n      {\n        error: \"Failed to fetch conversation details\",\n        details: error instanceof Error ? error.message : String(error),\n      },\n      500,\n    );\n  }\n}\n", "import { Context } from \"hono\";\nimport { query, type PermissionMode } from \"@anthropic-ai/claude-code\";\nimport type { ChatRequest, StreamResponse } from \"../../shared/types.ts\";\nimport { logger } from \"../utils/logger.ts\";\n\n/**\n * Executes a Claude command and yields streaming responses\n * @param message - User message or command\n * @param requestId - Unique request identifier for abort functionality\n * @param requestAbortControllers - Shared map of abort controllers\n * @param cliPath - Path to actual CLI script (detected by validateClaudeCli)\n * @param sessionId - Optional session ID for conversation continuity\n * @param allowedTools - Optional array of allowed tool names\n * @param workingDirectory - Optional working directory for Claude execution\n * @param permissionMode - Optional permission mode for Claude execution\n * @returns AsyncGenerator yielding StreamResponse objects\n */\nasync function* executeClaudeCommand(\n  message: string,\n  requestId: string,\n  requestAbortControllers: Map<string, AbortController>,\n  cliPath: string,\n  sessionId?: string,\n  allowedTools?: string[],\n  workingDirectory?: string,\n  permissionMode?: PermissionMode,\n): AsyncGenerator<StreamResponse> {\n  let abortController: AbortController;\n\n  try {\n    // Process commands that start with '/'\n    let processedMessage = message;\n    if (message.startsWith(\"/\")) {\n      // Remove the '/' and send just the command\n      processedMessage = message.substring(1);\n    }\n\n    // Create and store AbortController for this request\n    abortController = new AbortController();\n    requestAbortControllers.set(requestId, abortController);\n\n    for await (const sdkMessage of query({\n      prompt: processedMessage,\n      options: {\n        abortController,\n        executable: \"node\" as const,\n        executableArgs: [],\n        pathToClaudeCodeExecutable: cliPath,\n        ...(sessionId ? { resume: sessionId } : {}),\n        ...(allowedTools ? { allowedTools } : {}),\n        ...(workingDirectory ? { cwd: workingDirectory } : {}),\n        ...(permissionMode ? { permissionMode } : {}),\n      },\n    })) {\n      // Debug logging of raw SDK messages with detailed content\n      logger.chat.debug(\"Claude SDK Message: {sdkMessage}\", { sdkMessage });\n\n      yield {\n        type: \"claude_json\",\n        data: sdkMessage,\n      };\n    }\n\n    yield { type: \"done\" };\n  } catch (error) {\n    // Check if error is due to abort\n    // TODO: Re-enable when AbortError is properly exported from Claude SDK\n    // if (error instanceof AbortError) {\n    //   yield { type: \"aborted\" };\n    // } else {\n    {\n      logger.chat.error(\"Claude Code execution failed: {error}\", { error });\n      yield {\n        type: \"error\",\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  } finally {\n    // Clean up AbortController from map\n    if (requestAbortControllers.has(requestId)) {\n      requestAbortControllers.delete(requestId);\n    }\n  }\n}\n\n/**\n * Handles POST /api/chat requests with streaming responses\n * @param c - Hono context object with config variables\n * @param requestAbortControllers - Shared map of abort controllers\n * @returns Response with streaming NDJSON\n */\nexport async function handleChatRequest(\n  c: Context,\n  requestAbortControllers: Map<string, AbortController>,\n) {\n  const chatRequest: ChatRequest = await c.req.json();\n  const { cliPath } = c.var.config;\n\n  logger.chat.debug(\n    \"Received chat request {*}\",\n    chatRequest as unknown as Record<string, unknown>,\n  );\n\n  const stream = new ReadableStream({\n    async start(controller) {\n      try {\n        for await (const chunk of executeClaudeCommand(\n          chatRequest.message,\n          chatRequest.requestId,\n          requestAbortControllers,\n          cliPath, // Use detected CLI path from validateClaudeCli\n          chatRequest.sessionId,\n          chatRequest.allowedTools,\n          chatRequest.workingDirectory,\n          chatRequest.permissionMode,\n        )) {\n          const data = JSON.stringify(chunk) + \"\\n\";\n          controller.enqueue(new TextEncoder().encode(data));\n        }\n        controller.close();\n      } catch (error) {\n        const errorResponse: StreamResponse = {\n          type: \"error\",\n          error: error instanceof Error ? error.message : String(error),\n        };\n        controller.enqueue(\n          new TextEncoder().encode(JSON.stringify(errorResponse) + \"\\n\"),\n        );\n        controller.close();\n      }\n    },\n  });\n\n  return new Response(stream, {\n    headers: {\n      \"Content-Type\": \"application/x-ndjson\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n    },\n  });\n}\n", "import { Context } from \"hono\";\nimport { logger } from \"../utils/logger.ts\";\n\n/**\n * Handles POST /api/abort/:requestId requests\n * Aborts an ongoing chat request by request ID\n * @param c - Hono context object with config variables\n * @param requestAbortControllers - Map of request IDs to AbortControllers\n * @returns JSON response indicating success or failure\n */\nexport function handleAbortRequest(\n  c: Context,\n  requestAbortControllers: Map<string, AbortController>,\n) {\n  const requestId = c.req.param(\"requestId\");\n\n  if (!requestId) {\n    return c.json({ error: \"Request ID is required\" }, 400);\n  }\n\n  logger.api.debug(`Abort attempt for request: ${requestId}`);\n  logger.api.debug(\n    `Active requests: ${Array.from(requestAbortControllers.keys())}`,\n  );\n\n  const abortController = requestAbortControllers.get(requestId);\n  if (abortController) {\n    abortController.abort();\n    requestAbortControllers.delete(requestId);\n\n    logger.api.debug(`Aborted request: ${requestId}`);\n\n    return c.json({ success: true, message: \"Request aborted\" });\n  } else {\n    return c.json({ error: \"Request not found or already completed\" }, 404);\n  }\n}\n", "/**\n * Node.js runtime implementation\n *\n * Simplified implementation focusing only on platform-specific operations.\n */\n\nimport { spawn, type SpawnOptions } from \"node:child_process\";\nimport process from \"node:process\";\nimport { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport type { CommandResult, Runtime } from \"./types.ts\";\nimport type { MiddlewareHandler } from \"hono\";\nimport { serveStatic } from \"@hono/node-server/serve-static\";\nimport { getPlatform } from \"../utils/os.ts\";\n\nexport class NodeRuntime implements Runtime {\n  async findExecutable(name: string): Promise<string[]> {\n    const platform = getPlatform();\n    const candidates: string[] = [];\n\n    if (platform === \"windows\") {\n      // Try multiple possible executable names on Windows\n      const executableNames = [\n        name,\n        `${name}.exe`,\n        `${name}.cmd`,\n        `${name}.bat`,\n      ];\n\n      for (const execName of executableNames) {\n        const result = await this.runCommand(\"where\", [execName]);\n        if (result.success && result.stdout.trim()) {\n          // where command can return multiple paths, split by newlines\n          const paths = result.stdout\n            .trim()\n            .split(\"\\n\")\n            .map((p) => p.trim())\n            .filter((p) => p);\n          candidates.push(...paths);\n        }\n      }\n    } else {\n      // Unix-like systems (macOS, Linux)\n      const result = await this.runCommand(\"which\", [name]);\n      if (result.success && result.stdout.trim()) {\n        candidates.push(result.stdout.trim());\n      }\n    }\n\n    return candidates;\n  }\n\n  runCommand(\n    command: string,\n    args: string[],\n    options?: { env?: Record<string, string> },\n  ): Promise<CommandResult> {\n    return new Promise((resolve) => {\n      const isWindows = getPlatform() === \"windows\";\n      const spawnOptions: SpawnOptions = {\n        stdio: [\"ignore\", \"pipe\", \"pipe\"],\n        env: options?.env ? { ...process.env, ...options.env } : process.env,\n      };\n\n      // On Windows, always use cmd.exe /c for all commands\n      let actualCommand = command;\n      let actualArgs = args;\n\n      if (isWindows) {\n        actualCommand = \"cmd.exe\";\n        actualArgs = [\"/c\", command, ...args];\n      }\n\n      const child = spawn(actualCommand, actualArgs, spawnOptions);\n\n      const textDecoder = new TextDecoder();\n      let stdout = \"\";\n      let stderr = \"\";\n\n      child.stdout?.on(\"data\", (data: Uint8Array) => {\n        stdout += textDecoder.decode(data, { stream: true });\n      });\n\n      child.stderr?.on(\"data\", (data: Uint8Array) => {\n        stderr += textDecoder.decode(data, { stream: true });\n      });\n\n      child.on(\"close\", (code: number | null) => {\n        resolve({\n          success: code === 0,\n          code: code ?? 1,\n          stdout,\n          stderr,\n        });\n      });\n\n      child.on(\"error\", (error: Error) => {\n        resolve({\n          success: false,\n          code: 1,\n          stdout: \"\",\n          stderr: error.message,\n        });\n      });\n    });\n  }\n\n  serve(\n    port: number,\n    hostname: string,\n    handler: (req: Request) => Response | Promise<Response>,\n  ): void {\n    // Use Hono with Node.js server to handle Web API Request/Response\n    const app = new Hono();\n\n    // Route all requests to the provided handler\n    app.all(\"*\", async (c) => {\n      const response = await handler(c.req.raw);\n      return response;\n    });\n\n    // Start the server using @hono/node-server\n    serve({\n      fetch: app.fetch,\n      port,\n      hostname,\n    });\n\n    console.log(`Listening on http://${hostname}:${port}/`);\n  }\n\n  createStaticFileMiddleware(options: { root: string }): MiddlewareHandler {\n    return serveStatic(options);\n  }\n}\n", "/**\n * CLI argument parsing using runtime abstraction\n *\n * Handles command-line argument parsing in a runtime-agnostic way.\n */\n\nimport { program } from \"commander\";\nimport { VERSION } from \"./version.ts\";\nimport { getEnv, getArgs } from \"../utils/os.ts\";\n\nexport interface ParsedArgs {\n  debug: boolean;\n  port: number;\n  host: string;\n  claudePath?: string;\n}\n\nexport function parseCliArgs(): ParsedArgs {\n  // Use version from auto-generated version.ts file\n  const version = VERSION;\n\n  // Get default port from environment\n  const defaultPort = parseInt(getEnv(\"PORT\") || \"8080\", 10);\n\n  // Configure program\n  program\n    .name(\"claude-code-webui\")\n    .version(version, \"-v, --version\", \"display version number\")\n    .description(\"Claude Code Web UI Backend Server\")\n    .option(\n      \"-p, --port <port>\",\n      \"Port to listen on\",\n      (value) => {\n        const parsed = parseInt(value, 10);\n        if (isNaN(parsed)) {\n          throw new Error(`Invalid port number: ${value}`);\n        }\n        return parsed;\n      },\n      defaultPort,\n    )\n    .option(\n      \"--host <host>\",\n      \"Host address to bind to (use 0.0.0.0 for all interfaces)\",\n      \"127.0.0.1\",\n    )\n    .option(\n      \"--claude-path <path>\",\n      \"Path to claude executable (overrides automatic detection)\",\n    )\n    .option(\"-d, --debug\", \"Enable debug mode\", false);\n\n  // Parse arguments - Commander.js v14 handles this automatically\n  program.parse(getArgs(), { from: \"user\" });\n  const options = program.opts();\n\n  // Handle DEBUG environment variable manually\n  const debugEnv = getEnv(\"DEBUG\");\n  const debugFromEnv = debugEnv?.toLowerCase() === \"true\" || debugEnv === \"1\";\n\n  return {\n    debug: options.debug || debugFromEnv,\n    port: options.port,\n    host: options.host,\n    claudePath: options.claudePath,\n  };\n}\n", "// Auto-generated file - do not edit manually\n// This file is generated by scripts/generate-version.js\nexport const VERSION = \"0.1.56\";\n", "/**\n * Shared CLI validation utilities\n *\n * Common validation functions used across different runtime CLI entry points.\n */\n\nimport { dirname, join } from \"node:path\";\nimport type { Runtime } from \"../runtime/types.ts\";\nimport { logger } from \"../utils/logger.ts\";\nimport {\n  readTextFile,\n  writeTextFile,\n  exists,\n  withTempDir,\n} from \"../utils/fs.ts\";\nimport { getPlatform, getEnv, exit } from \"../utils/os.ts\";\n\n// Regex to fix double backslashes that might occur during Windows path string processing\nconst DOUBLE_BACKSLASH_REGEX = /\\\\\\\\/g;\n\n/**\n * Parses Windows .cmd script to extract the actual CLI script path\n * Handles NPM cmd-shim execution line pattern: \"%_prog%\" args \"%dp0%\\script.js\" %*\n * Skips IF EXIST conditions and targets the actual execution line\n * @param runtime - Runtime abstraction for system operations\n * @param cmdPath - Path to the .cmd file to parse\n * @returns Promise<string | null> - The extracted CLI script path or null if parsing fails\n */\nasync function parseCmdScript(cmdPath: string): Promise<string | null> {\n  try {\n    logger.cli.debug(`Parsing Windows .cmd script: ${cmdPath}`);\n    const cmdContent = await readTextFile(cmdPath);\n\n    // Extract directory of the .cmd file for resolving relative paths\n    const cmdDir = dirname(cmdPath);\n\n    // Match NPM cmd-shim execution line pattern: \"%_prog%\" args \"%dp0%\\script.js\" %*\n    // Skip IF EXIST conditions and target the actual execution line\n    const execLineMatch = cmdContent.match(/\"%_prog%\"[^\"]*\"(%dp0%\\\\[^\"]+)\"/);\n    if (execLineMatch) {\n      const fullPath = execLineMatch[1]; // \"%dp0%\\path\\to\\script.js\"\n      // Extract the relative path part after %dp0%\\\n      const pathMatch = fullPath.match(/%dp0%\\\\(.+)/);\n      if (pathMatch) {\n        const relativePath = pathMatch[1];\n        const absolutePath = join(cmdDir, relativePath);\n\n        logger.cli.debug(`Found CLI script reference: ${relativePath}`);\n        logger.cli.debug(`Resolved absolute path: ${absolutePath}`);\n\n        // Verify the resolved path exists\n        if (await exists(absolutePath)) {\n          logger.cli.debug(`.cmd parsing successful: ${absolutePath}`);\n          return absolutePath;\n        } else {\n          logger.cli.debug(`Resolved path does not exist: ${absolutePath}`);\n        }\n      } else {\n        logger.cli.debug(`Could not extract relative path from: ${fullPath}`);\n      }\n    } else {\n      logger.cli.debug(`No CLI script execution pattern found in .cmd content`);\n    }\n\n    return null;\n  } catch (error) {\n    logger.cli.debug(\n      `Failed to parse .cmd script: ${error instanceof Error ? error.message : String(error)}`,\n    );\n    return null;\n  }\n}\n\n/**\n * Generates Windows batch wrapper script\n * @param traceFile - Path to trace output file\n * @param nodePath - Path to original node executable\n * @returns Windows batch script content\n */\nfunction getWindowsWrapperScript(traceFile: string, nodePath: string): string {\n  return `@echo off\\necho %~1 >> \"${traceFile}\"\\n\"${nodePath}\" %*`;\n}\n\n/**\n * Generates Unix shell wrapper script\n * @param traceFile - Path to trace output file\n * @param nodePath - Path to original node executable\n * @returns Unix shell script content\n */\nfunction getUnixWrapperScript(traceFile: string, nodePath: string): string {\n  return `#!/bin/bash\\necho \"$1\" >> \"${traceFile}\"\\nexec \"${nodePath}\" \"$@\"`;\n}\n\n/**\n * Detects the actual Claude script path by tracing node execution\n * Uses a temporary node wrapper to capture the actual script path being executed by Claude CLI\n * @param runtime - Runtime abstraction for system operations\n * @param claudePath - Path to the claude executable\n * @returns Promise<{scriptPath: string, versionOutput: string}> - The actual Claude script path and version output, or empty strings if detection fails\n */\nexport async function detectClaudeCliPath(\n  runtime: Runtime,\n  claudePath: string,\n): Promise<{ scriptPath: string; versionOutput: string }> {\n  const platform = getPlatform();\n  const isWindows = platform === \"windows\";\n\n  // First try PATH wrapping method\n  let pathWrappingResult: { scriptPath: string; versionOutput: string } | null =\n    null;\n\n  try {\n    pathWrappingResult = await withTempDir(async (tempDir: string) => {\n      const traceFile = `${tempDir}/trace.log`;\n\n      // Find the original node executable\n      const nodeExecutables = await runtime.findExecutable(\"node\");\n      if (nodeExecutables.length === 0) {\n        // Silently return null - this is not a critical error\n        return null;\n      }\n\n      const originalNodePath = nodeExecutables[0];\n\n      // Create platform-specific wrapper script\n      const wrapperFileName = isWindows ? \"node.bat\" : \"node\";\n      const wrapperScript = isWindows\n        ? getWindowsWrapperScript(traceFile, originalNodePath)\n        : getUnixWrapperScript(traceFile, originalNodePath);\n\n      await writeTextFile(\n        `${tempDir}/${wrapperFileName}`,\n        wrapperScript,\n        isWindows ? undefined : { mode: 0o755 },\n      );\n\n      // Execute claude with modified PATH to intercept node calls\n      const currentPath = getEnv(\"PATH\") || \"\";\n      const modifiedPath = isWindows\n        ? `${tempDir};${currentPath}`\n        : `${tempDir}:${currentPath}`;\n\n      const executionResult = await runtime.runCommand(\n        claudePath,\n        [\"--version\"],\n        {\n          env: { PATH: modifiedPath },\n        },\n      );\n\n      // Verify command executed successfully\n      if (!executionResult.success) {\n        return null;\n      }\n\n      const versionOutput = executionResult.stdout.trim();\n\n      // Parse trace file to extract script path\n      let traceContent: string;\n      try {\n        traceContent = await readTextFile(traceFile);\n      } catch {\n        // Trace file might not exist or be readable\n        return { scriptPath: \"\", versionOutput };\n      }\n\n      if (!traceContent.trim()) {\n        // Empty trace file indicates no node execution was captured\n        return { scriptPath: \"\", versionOutput };\n      }\n\n      const traceLines = traceContent\n        .split(\"\\n\")\n        .map((line) => line.trim())\n        .filter((line) => line.length > 0);\n\n      // Find the Claude script path from traced node executions\n      for (const traceLine of traceLines) {\n        let scriptPath = traceLine.trim();\n\n        // Clean up the script path\n        if (scriptPath) {\n          // Fix double backslashes that might occur during string processing\n          if (isWindows) {\n            scriptPath = scriptPath.replace(DOUBLE_BACKSLASH_REGEX, \"\\\\\");\n          }\n        }\n\n        if (scriptPath) {\n          return { scriptPath, versionOutput };\n        }\n      }\n\n      // No Claude script path found in trace\n      return { scriptPath: \"\", versionOutput };\n    });\n  } catch (error) {\n    // Log error for debugging but don't crash the application\n    logger.cli.debug(\n      `PATH wrapping detection failed: ${error instanceof Error ? error.message : String(error)}`,\n    );\n    pathWrappingResult = null;\n  }\n\n  // If PATH wrapping succeeded, return the result\n  if (pathWrappingResult && pathWrappingResult.scriptPath) {\n    return pathWrappingResult;\n  }\n\n  // Try Windows .cmd parsing fallback if PATH wrapping didn't work\n  if (isWindows && claudePath.endsWith(\".cmd\")) {\n    logger.cli.debug(\n      \"PATH wrapping method failed, trying .cmd parsing fallback...\",\n    );\n    try {\n      const cmdParsedPath = await parseCmdScript(claudePath);\n      if (cmdParsedPath) {\n        // Get version output, use from PATH wrapping if available\n        let versionOutput = pathWrappingResult?.versionOutput || \"\";\n        if (!versionOutput) {\n          try {\n            const versionResult = await runtime.runCommand(claudePath, [\n              \"--version\",\n            ]);\n            if (versionResult.success) {\n              versionOutput = versionResult.stdout.trim();\n            }\n          } catch {\n            // Ignore version detection errors\n          }\n        }\n        return { scriptPath: cmdParsedPath, versionOutput };\n      }\n    } catch (fallbackError) {\n      logger.cli.debug(\n        `.cmd parsing fallback failed: ${fallbackError instanceof Error ? fallbackError.message : String(fallbackError)}`,\n      );\n    }\n  }\n\n  // Both methods failed, return empty result but preserve version output if available\n  return {\n    scriptPath: \"\",\n    versionOutput: pathWrappingResult?.versionOutput || \"\",\n  };\n}\n\n/**\n * Validates that the Claude CLI is available and detects the actual CLI script path\n * Uses detectClaudeCliPath for universal path detection regardless of installation method\n * Exits process if Claude CLI is not found or not working\n * @param runtime - Runtime abstraction for system operations\n * @param customPath - Optional custom path to claude executable to validate\n * @returns Promise<string> - The detected actual CLI script path or validated claude path\n */\nexport async function validateClaudeCli(\n  runtime: Runtime,\n  customPath?: string,\n): Promise<string> {\n  try {\n    // Get platform information once at the beginning\n    const platform = getPlatform();\n    const isWindows = platform === \"windows\";\n\n    let claudePath = \"\";\n\n    if (customPath) {\n      // Use custom path if provided\n      claudePath = customPath;\n      logger.cli.info(`\uD83D\uDD0D Validating custom Claude path: ${customPath}`);\n    } else {\n      // Auto-detect using runtime's findExecutable method\n      logger.cli.info(\"\uD83D\uDD0D Searching for Claude CLI in PATH...\");\n      const candidates = await runtime.findExecutable(\"claude\");\n\n      if (candidates.length === 0) {\n        logger.cli.error(\"\u274C Claude CLI not found in PATH\");\n        logger.cli.error(\"   Please install claude-code globally:\");\n        logger.cli.error(\n          \"   Visit: https://claude.ai/code for installation instructions\",\n        );\n        exit(1);\n      }\n\n      // On Windows, prefer .cmd files when multiple candidates exist\n      if (isWindows && candidates.length > 1) {\n        const cmdCandidate = candidates.find((path) => path.endsWith(\".cmd\"));\n        claudePath = cmdCandidate || candidates[0];\n        logger.cli.debug(\n          `Found Claude CLI candidates: ${candidates.join(\", \")}`,\n        );\n        logger.cli.debug(\n          `Using Claude CLI path: ${claudePath} (Windows .cmd preferred)`,\n        );\n      } else {\n        // Use the first candidate (most likely to be the correct one)\n        claudePath = candidates[0];\n        logger.cli.debug(\n          `Found Claude CLI candidates: ${candidates.join(\", \")}`,\n        );\n        logger.cli.debug(`Using Claude CLI path: ${claudePath}`);\n      }\n    }\n\n    // Check if this is a Windows .cmd file for enhanced debugging\n    const isCmdFile = claudePath.endsWith(\".cmd\");\n\n    if (isWindows && isCmdFile) {\n      logger.cli.debug(\n        \"Detected Windows .cmd file - fallback parsing available if needed\",\n      );\n    }\n\n    // Detect the actual CLI script path using tracing approach\n    logger.cli.info(\"\uD83D\uDD0D Detecting actual Claude CLI script path...\");\n    const detection = await detectClaudeCliPath(runtime, claudePath);\n\n    if (detection.scriptPath) {\n      logger.cli.info(`\u2705 Claude CLI script detected: ${detection.scriptPath}`);\n      if (detection.versionOutput) {\n        logger.cli.info(`\u2705 Claude CLI found: ${detection.versionOutput}`);\n      }\n      return detection.scriptPath;\n    } else {\n      // Show warning but continue with fallback when detection fails\n      logger.cli.warn(\"\u26A0\uFE0F  Claude CLI script path detection failed\");\n      logger.cli.warn(\n        \"   Falling back to using the claude executable directly.\",\n      );\n      logger.cli.warn(\"   This may not work properly, but continuing anyway.\");\n      logger.cli.warn(\"\");\n      logger.cli.warn(`   Using fallback path: ${claudePath}`);\n      if (detection.versionOutput) {\n        logger.cli.info(`\u2705 Claude CLI found: ${detection.versionOutput}`);\n      }\n      return claudePath;\n    }\n  } catch (error) {\n    logger.cli.error(\"\u274C Failed to validate Claude CLI\");\n    logger.cli.error(\n      `   Error: ${error instanceof Error ? error.message : String(error)}`,\n    );\n    exit(1);\n  }\n}\n", "#!/usr/bin/env node\n/**\n * Node.js-specific entry point\n *\n * This module handles Node.js-specific initialization including CLI argument parsing,\n * Claude CLI validation, and server startup using the NodeRuntime.\n */\n\nimport { createApp } from \"../app.ts\";\nimport { NodeRuntime } from \"../runtime/node.ts\";\nimport { parseCliArgs } from \"./args.ts\";\nimport { validateClaudeCli } from \"./validation.ts\";\nimport { setupLogger, logger } from \"../utils/logger.ts\";\nimport { fileURLToPath } from \"node:url\";\nimport { dirname, join } from \"node:path\";\nimport { exit } from \"../utils/os.ts\";\n\nasync function main(runtime: NodeRuntime) {\n  // Parse CLI arguments\n  const args = parseCliArgs();\n\n  // Initialize logging system\n  await setupLogger(args.debug);\n\n  if (args.debug) {\n    logger.cli.info(\"\uD83D\uDC1B Debug mode enabled\");\n  }\n\n  // Validate Claude CLI availability and get the detected CLI path\n  const cliPath = await validateClaudeCli(runtime, args.claudePath);\n\n  // Use absolute path for static files (supported in @hono/node-server v1.17.0+)\n  // Node.js 20.11.0+ compatible with fallback for older versions\n  const __dirname =\n    import.meta.dirname ?? dirname(fileURLToPath(import.meta.url));\n  const staticPath = join(__dirname, \"../static\");\n\n  // Create application\n  const app = createApp(runtime, {\n    debugMode: args.debug,\n    staticPath,\n    cliPath,\n  });\n\n  // Start server (only show this message when everything is ready)\n  logger.cli.info(`\uD83D\uDE80 Server starting on ${args.host}:${args.port}`);\n  runtime.serve(args.port, args.host, app.fetch);\n}\n\n// Run the application\nconst runtime = new NodeRuntime();\nmain(runtime).catch((error) => {\n  // Logger may not be initialized yet, so use console.error\n  console.error(\"Failed to start server:\", error);\n  exit(1);\n});\n"],
  "mappings": "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ChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,MAAQ,IAAO;EAChB,CAAC,OAAQ,KAAO;EAChB,CAAC,OAAQ,KAAO;AACjB;AAGD,IAAM,qBAAqB,oBAAI,IAAI;EACjC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACD,CAAA;AAKD,SAAS,WAAWD,MAAcE,QAA0C;AAC1E,MAAI,OAAO;AACX,MAAI,QAAQ,OAAO,SAAS;AAE5B,SAAO,QAAQ,OAAO;AACpB,UAAM,MAAM,KAAK,OAAO,OAAO,SAAS,CAAA;AACxC,UAAM,CAAC,OAAO,GAAA,IAAO,OAAO,GAAA;AAE5B,QAAI,QAAQ,SAAS,QAAQ,IAC3B,QAAO;aACE,OAAO,MAChB,SAAQ,MAAM;QAEd,QAAO,MAAM;EAEhB;AAED,SAAO;AACR;AASD,SAAS,YAAYF,MAAuB;AAC1C,SAAO,mBAAmB,IAAI,IAAA,KAAS,WAAW,MAAM,iBAAA;AACzD;AASD,SAAS,gBAAgBA,MAAuB;AAE9C,SAEG,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC3B,SAAS,QAAU,SAAS,QAC3B,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC3B,SAAS,QAAU,SAAS,QAC5B,SAAS,QAAU,SAAS,QAAU,SAAS,QAAU,SAAS,QACjE,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC3B,SAAS,QAAU,SAAS,QAC3B,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC3B,SAAS,QAAU,SAAS,QAC5B,SAAS,QACR,QAAQ,QAAU,QAAQ,QAC1B,QAAQ,QAAU,QAAQ,QAC3B,SAAS,SACT,SAAS,SACT,SAAS,SACR,QAAQ,SAAU,QAAQ,SAC3B,SAAS,SACR,QAAQ,SAAU,QAAQ,SAC3B,SAAS,SAAU,SAAS,SAC3B,QAAQ,SAAU,QAAQ,SAC3B,SAAS,SAAU,SAAS,SAC3B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAU,QAAQ,SAC1B,QAAQ,SAAW,QAAQ,SAC3B,QAAQ,SAAW,QAAQ,SAC3B,QAAQ,SAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC5B,SAAS,UACT,SAAS,UACR,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ,UAC3B,QAAQ,UAAW,QAAQ;AAG/B;;;ACzYD,SAAgB,SACdG,MACAC,UACAC,gBACQ;AACR,MAAI,YAAY,EAAG,QAAO;AAE1B,QAAM,eAAe,gBAAgB,IAAA;AAGrC,MAAI,gBAAgB,YAAA,CAAa,KAAK,SAAS,IAAA,EAAO,QAAO;AAG7D,QAAM,iBAAiB,eAAe,MAAM,GAAA;AAC5C,QAAM,YAAY,eAAe,CAAA;AACjC,QAAM,YAAY,UAAU,IAAA;AAC5B,QAAM,oBAAoB,UAAU,QAAQ,SAAA;AAI5C,MAAI,cAAc;AAClB,MAAI,qBAAqB,GAAG;AAC1B,UAAM,aAAa,UAAU,MAAM,GAAG,iBAAA;AACtC,kBAAc,gBAAgB,UAAA;EAC/B;AACD,QAAM,SAAS,IAAI,OAAO,KAAK,IAAI,GAAG,WAAA,CAAY;AAGlD,MAAI,KAAK,SAAS,IAAA,GAAO;AAEvB,UAAM,QAAQ,KAAK,MAAM,IAAA;AACzB,UAAMC,eAAyB,CAAE;AAEjC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAA;AACnB,YAAM,mBAAmB,gBAAgB,IAAA;AAEzC,UAAI,oBAAoB,SAEtB,KAAI,MAAM,EACR,cAAa,KAAK,IAAA;UAElB,cAAa,KAAK,SAAS,IAAA;WAExB;AAEL,cAAM,cAAc,eAAe,MAAM,UAAU,MAAA;AACnD,YAAI,MAAM,EACR,cAAa,KAAK,WAAA;aACb;AAEL,gBAAM,WAAW,YAAY,MAAM,IAAA;AACnC,mBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,IACnC,KAAI,MAAM,EACR,cAAa,KAAK,SAAS,SAAS,CAAA,CAAA;cAEpC,cAAa,KAAK,SAAS,CAAA,CAAA;QAGhC;MACF;IACF;AAED,WAAO,aAAa,KAAK,IAAA;EAC1B;AAGD,SAAO,eAAe,MAAM,UAAU,MAAA;AACvC;AAWD,SAAgB,eACdH,MACAC,UACAG,QACQ;AAER,QAAMC,QAAkB,CAAE;AAC1B,MAAI,cAAc;AAClB,MAAI,sBAAsB;AAC1B,MAAI,IAAI;AAER,SAAO,IAAI,KAAK,QAAQ;AAEtB,QAAI,KAAK,CAAA,MAAO,UAAU,KAAK,IAAI,CAAA,MAAO,KAAK;AAE7C,UAAI,IAAI,IAAI;AACZ,aAAO,IAAI,KAAK,UAAU,KAAK,CAAA,MAAO,IACpC;AAEF,UAAI,IAAI,KAAK,QAAQ;AACnB;AACA,uBAAe,KAAK,MAAM,GAAG,CAAA;AAC7B,YAAI;AACJ;MACD;IACF;AAED,UAAM,OAAO,KAAK,CAAA;AAGlB,QAAI,uBAAuB,YAAY,SAAS,KAAK;AAEnD,YAAM,aAAa,YAAY,YAAY,GAAA;AAC3C,UAAI,aAAa,GAAG;AAElB,cAAM,KAAK,YAAY,MAAM,GAAG,UAAA,CAAW;AAC3C,sBAAc,SAAS,YAAY,MAAM,aAAa,CAAA,IAAK;AAC3D,8BAAsB,gBAAgB,WAAA;MACvC,OAAM;AAEL,cAAM,KAAK,WAAA;AACX,sBAAc,SAAS;AACvB,8BAAsB,gBAAgB,WAAA;MACvC;IACF,OAAM;AACL,qBAAe;AAEf,4BAAsB,gBAAgB,WAAA;IACvC;AAED;EACD;AAED,MAAI,YAAY,KAAA,EACd,OAAM,KAAK,WAAA;AAIb,QAAM,gBAAgB,MAAM,OAAO,CAAC,SAAS,KAAK,KAAA,EAAO,SAAS,CAAA;AAElE,SAAO,cAAc,KAAK,IAAA;AAC3B;;;;ACvJD,SAAgBC,SAAQC,KAAcC,SAAkC;AACtE,SAAOC,MAAK,QAAQ,KAAK,OAAA;AAC1B;;;ACID,IAAMC,SAAQ;AACd,IAAM,MAAM;AAGZ,IAAM,gBAAgB;EACpB,OAAO;EACP,OAAO;EACP,MAAM;EACN,SAAS;EACT,OAAO;EACP,OAAO;EACP,UAAU;EACV,SAAS;EACT,WAAW;AACZ;AAKD,IAAM,SAAS;EACb,OAAOA;EACP,MAAM;EACN,KAAK;EACL,QAAQ;EACR,WAAW;EACX,eAAe;AAChB;AAKD,IAAMC,cAAa;EACjB,OAAO;EACP,KAAK;EACL,OAAO;EACP,QAAQ;EACR,MAAM;EACN,SAAS;EACT,MAAM;EACN,OAAO;AACR;AA4CD,IAAM,cAAc;AACpB,IAAM,cAAc;AAKpB,SAAS,YAAYC,OAAsB;AACzC,MAAI,UAAU,KAAM,QAAO;AAC3B,MAAI,SAASD,YACX,QAAOA,YAAW,KAAA;AAIpB,QAAM,WAAW,MAAM,MAAM,WAAA;AAC7B,MAAI,UAAU;AACZ,UAAM,CAAA,EAAG,GAAG,GAAG,CAAA,IAAK;AACpB,WAAA,aAAoB,CAAA,IAAK,CAAA,IAAK,CAAA;EAC/B;AAGD,QAAM,WAAW,MAAM,MAAM,WAAA;AAC7B,MAAI,UAAU;AACZ,QAAI,MAAM,SAAS,CAAA;AAEnB,QAAI,IAAI,WAAW,EACjB,OAAM,IAAI,MAAM,EAAA,EAAI,IAAI,CAAC,MAAM,IAAI,CAAA,EAAG,KAAK,EAAA;AAE7C,UAAM,IAAI,SAAS,IAAI,OAAO,GAAG,CAAA,GAAI,EAAA;AACrC,UAAM,IAAI,SAAS,IAAI,OAAO,GAAG,CAAA,GAAI,EAAA;AACrC,UAAM,IAAI,SAAS,IAAI,OAAO,GAAG,CAAA,GAAI,EAAA;AACrC,WAAA,aAAoB,CAAA,IAAK,CAAA,IAAK,CAAA;EAC/B;AAED,SAAO;AACR;AAKD,SAAS,YAAYE,OAAsB;AACzC,MAAI,UAAU,KAAM,QAAO;AAC3B,MAAI,MAAM,QAAQ,KAAA,EAChB,QAAO,MAAM,IAAI,CAAC,MAAM,OAAO,CAAA,KAAM,EAAA,EAAI,KAAK,EAAA;AAEhD,SAAO,OAAO,KAAA,KAAU;AACzB;AAMD,SAAS,wBACPC,kBACmB;AACnB,QAAMC,WAA8B,CAAE;AAEtC,aAAW,CAAC,QAAQ,KAAA,KAAU,iBAC5B,UAAS,KAAK;IAAE;IAAQ;EAAO,CAAA;AAIjC,SAAO,SAAS,KAAK,CAAC,GAAG,MAAM,EAAE,OAAO,SAAS,EAAE,OAAO,MAAA;AAC3D;AAMD,SAAS,mBACPC,UACAD,UACO;AACP,aAAW,WAAW,SACpB,KAAI,gBAAgB,UAAU,QAAQ,MAAA,EACpC,QAAO,QAAQ;AAGnB,SAAO;AACR;AAMD,SAAS,gBACPC,UACAC,QACS;AACT,MAAI,OAAO,SAAS,SAAS,OAC3B,QAAO;AAGT,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IACjC,KAAI,SAAS,CAAA,MAAO,OAAO,CAAA,EACzB,QAAO;AAIX,SAAO;AACR;AAKD,IAAMC,eAAyC;EAC7C,OAAO;EACP,OAAO;EACP,MAAM;EACN,SAAS;EACT,OAAO;EACP,OAAO;AACR;AAWD,SAAS,qBACPC,SAC0B;AAC1B,QAAM,UAAU,OAAO,QAAQ,OAAA;AAC/B,QAAM,WAAW,KAAK,IACpB,GAAG,QAAQ,IAAI,CAAC,CAAA,EAAG,IAAA,MAAU,gBAAgB,IAAA,CAAK,CAAC;AAGrD,SAAO,OAAO,YACZ,QAAQ,IAAI,CAAC,CAAC,OAAO,IAAA,MAAU,CAC7B,OACA,OAAO,IAAI,OAAO,WAAW,gBAAgB,IAAA,CAAK,CACnD,CAAA,CAAC;AAEL;AAsZD,SAAgB,mBACdC,UAAkC,CAAE,GACrB;AAEf,QAAM,EACJ,YAAY,QACZ,iBAAiB,oBACjB,iBAAiB,OACjB,OAAO,cAAc,QACrB,cAAc,CAAE,GAChB,aAAa,aACb,QAAQ,MACR,oBAAoB,QACpB,gBAAgB,oBAChB,mBAAmB,oBAAI,IAAA,GACvB,gBAAgB,CAAC,OAAO,QAAS,GACjC,gBAAgB,IAChB,mBAAmB,UACnB,eAAe,oBACf,eAAe,OACf,QAAQ,YAAY,MACpB,QAAQ,MACR,iBAAiB,CAAE,GACnB,WAAW,KAAA,IACT;AAGJ,QAAMC,cAAwC,UAAU,QACpD;IAAE,OAAO;IAAI,OAAO;IAAI,MAAM;IAAI,SAAS;IAAI,OAAO;IAAI,OAAO;EAAI,IACrE,UAAU,OACV,eACA;IAAE,GAAG;IAAc,GAAI;EAA6C;AAGxE,QAAM,UAAU,qBAAqB,WAAA;AAGrC,QAAMC,sBAA+C;IACnD,OAAO,cAAc;IACrB,OAAO,cAAc;IACrB,MAAM,cAAc;IACpB,SAAS,cAAc;IACvB,OAAO,cAAc;IACrB,OAAO,cAAc;IACrB,GAAG;EACJ;AAGD,QAAMC,gBAA0D;IAC9D,QAAQ;MACN,OAAO;MACP,OAAO;MACP,MAAM;MACN,SAAS;MACT,OAAO;MACP,OAAO;IACR;IACD,KAAK;MACH,OAAO;MACP,OAAO;MACP,MAAM;MACN,SAAS;MACT,OAAO;MACP,OAAO;IACR;IACD,QAAQ;MACN,OAAO;MACP,OAAO;MACP,MAAM;MACN,SAAS;MACT,OAAO;MACP,OAAO;IACR;IACD,KAAK;MACH,OAAO;MACP,OAAO;MACP,MAAM;MACN,SAAS;MACT,OAAO;MACP,OAAO;IACR;EACF;AAED,QAAM,cAAc,CAACC,UAA4B;AAC/C,QAAA,OAAW,gBAAgB,WACzB,QAAO,YAAY,KAAA;AAGrB,QAAI,gBAAgB,OAAQ,QAAO,MAAM,YAAA;AACzC,QAAI,gBAAgB,OAAQ,QAAO;AAEnC,WAAO,cAAc,WAAA,IAAe,KAAA,KAAU;EAC/C;AAGD,QAAMC,uBAA8D;IAClE,sBAAsB,CAAC,OAAO;AAC5B,YAAM,MAAM,IAAI,KAAK,EAAA,EAAI,YAAA;AACzB,aAAO,IAAI,QAAQ,KAAK,GAAA,EAAK,QAAQ,KAAK,SAAA;IAC3C;IACD,gBAAgB,CAAC,OAAO;AACtB,YAAM,MAAM,IAAI,KAAK,EAAA,EAAI,YAAA;AACzB,aAAO,IAAI,QAAQ,KAAK,GAAA,EAAK,QAAQ,KAAK,MAAA;IAC3C;IACD,aAAa,CAAC,OAAO;AACnB,YAAM,MAAM,IAAI,KAAK,EAAA,EAAI,YAAA;AACzB,aAAO,IAAI,QAAQ,KAAK,GAAA,EAAK,QAAQ,KAAK,EAAA;IAC3C;IACD,iBAAiB,CAAC,OAAO;AACvB,YAAM,MAAM,IAAI,KAAK,EAAA,EAAI,YAAA;AACzB,aAAO,IAAI,QAAQ,OAAO,EAAA,EAAI,QAAQ,KAAK,SAAA;IAC5C;IACD,WAAW,CAAC,OAAO;AACjB,YAAM,MAAM,IAAI,KAAK,EAAA,EAAI,YAAA;AACzB,aAAO,IAAI,QAAQ,OAAO,EAAA,EAAI,QAAQ,KAAK,MAAA;IAC5C;IACD,QAAQ,CAAC,OAAO;AACd,YAAM,MAAM,IAAI,KAAK,EAAA,EAAI,YAAA;AACzB,aAAO,IAAI,QAAQ,OAAO,EAAA,EAAI,QAAQ,KAAK,EAAA;IAC5C;IACD,QAAQ,CAAC,OAAO,IAAI,KAAK,EAAA,EAAI,YAAA,EAAc,QAAQ,OAAO,EAAA;IAC1D,WAAW,CAAC,OAAO,IAAI,KAAK,EAAA,EAAI,YAAA;EACjC;AAGD,MAAIC,cAAsD;AAC1D,MAAI,cAAc,UAAU,cAAc,WACxC,eAAc;kBACE,cAAc,WAC9B,eAAc;MAEd,eAAcC,qBAAoB,SAAA,KAAwB;AAI5D,QAAM,kBAAkB,aAAa;AACrC,MAAIC;AAEJ,MAAA,OAAW,aAAa,SACtB,iBAAgB;WACP,aAAa,KAEtB,iBAAgB,wBAAwB,EAAA;MAExC,iBAAgB;AAIlB,QAAM,mBAAmB,wBAAwB,gBAAA;AAGjD,QAAMC,YAAwB;IAC5B;IACA;IACA;IACA;IACA;IACA;EACD;AACD,QAAM,aAAa,KAAK,IAAI,GAAG,UAAU,IAAI,CAAC,MAAM,YAAY,CAAA,EAAG,MAAA,CAAO;AAE1E,SAAO,CAACC,WAA8B;AAEpC,UAAM,OAAO,QAAQ,OAAO,KAAA,KAAU;AACtC,UAAM,QAAQ,YAAY,OAAO,KAAA;AACjC,UAAM,cAAc,iBAClB,OAAO,UACP,eACA,mBACA,gBAAA;AAIF,QAAI,UAAU;AACd,UAAM,mBAAmB,YAAY,YAAY,YAAA,IAAgB;AACjE,UAAM,mBAAmB,YAAY,YAAY,YAAA,IAAgB;AACjE,UAAM,gBAAgB,YAAA,GACf,gBAAA,GAAmB,gBAAA,KACtB;AAEJ,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,QAAQ,IACzC,KAAI,IAAI,MAAM,EACZ,YAAW,OAAO,QAAQ,CAAA;SACrB;AACL,YAAM,QAAQ,OAAO,QAAQ,CAAA;AAC7B,YAAM,YAAYC,SAAQ,OAAO;QAC/B,QAAQ;QACR,GAAG;MACJ,CAAA;AAGD,UAAI,UAAU,SAAS,IAAA,GAAO;AAC5B,cAAM,QAAQ,UAAU,MAAM,IAAA;AAE9B,cAAM,iBAAiB,MAAM,IAAI,CAAC,MAAM,UAAU;AAChD,cAAI,UAAU,EAEZ,KAAI,cAAc,oBAAoB,kBACpC,QAAA,GAAUrB,MAAA,GAAQ,IAAA,GAAO,aAAA;cAEzB,QAAO;mBAIL,cAAc,oBAAoB,kBACpC,QAAA,GAAU,IAAA,GAAO,aAAA;cAEjB,QAAO;QAGZ,CAAA;AACD,mBAAW,eAAe,KAAK,IAAA;MAChC,WAEK,cAAc,oBAAoB,kBACpC,YAAA,GAAcA,MAAA,GAAQ,SAAA,GAAY,aAAA;UAElC,YAAW;IAGhB;AAMH,UAAM,qBAAqB,YACtB,mBAAmB,OAAO,UAAU,gBAAA,KAAqB,gBAC1D;AAGJ,UAAM,gBAAgB;AACtB,QAAI,iBAAiB;AACrB,QAAI,oBAAoB;AACxB,QAAI,mBAAmB;AACvB,QAAI,qBAAqB;AAEzB,QAAI,WAAW;AAEb,YAAM,iBAAiB,YAAY,oBAAoB,OAAO,KAAA,CAAA;AAC9D,YAAM,iBAAiB,YAAY,UAAA;AACnC,uBAAA,GAAoB,cAAA,GAAiB,cAAA,GAAiB,KAAA,GAAQA,MAAA;AAG9D,YAAM,oBAAoB,YAAY,kBAAA;AACtC,YAAM,oBAAoB,YAAY,aAAA;AACtC,0BAAA,GACK,iBAAA,GAAoB,iBAAA,GAAoB,WAAA,GAAcA,MAAA;AAG3D,yBAAA,GAAsB,aAAA,GAAgB,OAAA,GAAUA,MAAA;IACjD;AAGD,QAAI,aAAa;AACf,YAAM,KAAK,YAAY,OAAO,SAAA;AAC9B,UAAI,OAAO,KACT,KAAI,WAAW;AACb,cAAM,qBAAqB,YAAY,cAAA;AACvC,cAAM,qBAAqB,YAAY,cAAA;AACvC,6BAAA,GACK,kBAAA,GAAqB,kBAAA,GAAqB,EAAA,GAAKA,MAAA;MACrD,MACC,sBAAA,GAAwB,EAAA;IAG7B;AAGD,QAAI,OAAO;AAET,YAAM,mBAAmB,YACpB,YAAY,oBAAoB,OAAO,KAAA,CAAA,EAAQ,SAChD,YAAY,UAAA,EAAY,SAASA,OAAM,SACvC;AACJ,YAAM,sBAAsB,YACvB,YAAY,kBAAA,EAAoB,SACjC,YAAY,aAAA,EAAe,SAASA,OAAM,SAC1C;AAEJ,YAAM,cAAc,eAAe,OAAO,aAAa,gBAAA;AACvD,YAAM,iBAAiB,kBAAkB,OACvC,gBAAgB,mBAAA;AAGlB,UAAI,SAAA,GACC,kBAAA,GAAqB,aAAA,IAAiB,WAAA,IAAe,cAAA,IAAkB,gBAAA;AAG5E,UAAI,mBAAmB,QAAQ,SAAS,IAAA,EACtC,UAAS,SACP,QACA,kBAAkB,gBAAgB,UAClC,OAAA;AAIJ,aAAO,SAAS;IACjB,OAAM;AACL,UAAI,SAAA,GACC,kBAAA,GAAqB,aAAA,IAAiB,cAAA,IAAkB,iBAAA,IAAqB,gBAAA;AAGlF,UAAI,mBAAmB,QAAQ,SAAS,IAAA,EACtC,UAAS,SACP,QACA,kBAAkB,gBAAgB,UAClC,OAAA;AAIJ,aAAO,SAAS;IACjB;EACF;AACF;AAoCD,IAAasB,kBAAiC,mBAAA;;;ACh9B9C,IAAI,eAAe;AAMnB,eAAsB,YAAY,WAAmC;AACnE,MAAI,cAAc;AAChB;AAAA,EACF;AAEA,QAAM,cAAwB,YAAY,UAAU;AAEpD,QAAM,UAAU;AAAA,IACd,OAAO;AAAA,MACL,SAAS,eAAe;AAAA,QACtB,WAAW,mBAAmB;AAAA,UAC5B,OAAO;AAAA;AAAA,UACP,OAAO;AAAA;AAAA,UACP,gBAAgB;AAAA,YACd,OAAO;AAAA;AAAA,YACP,QAAQ;AAAA;AAAA,YACR,SAAS;AAAA;AAAA,UACX;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,IACA,SAAS;AAAA,MACP;AAAA,QACE,UAAU,CAAC;AAAA,QACX;AAAA,QACA,OAAO,CAAC,SAAS;AAAA,MACnB;AAAA;AAAA,MAEA;AAAA,QACE,UAAU,CAAC,WAAW,MAAM;AAAA,QAC5B,aAAa;AAAA,QACb,OAAO,CAAC,SAAS;AAAA,MACnB;AAAA,IACF;AAAA,EACF,CAAC;AAED,iBAAe;AACjB;AAKO,IAAM,SAAS;AAAA;AAAA,EAEpB,KAAK,UAAU,CAAC,KAAK,CAAC;AAAA;AAAA,EAGtB,MAAM,UAAU,CAAC,MAAM,CAAC;AAAA;AAAA,EAGxB,SAAS,UAAU,CAAC,SAAS,CAAC;AAAA;AAAA,EAG9B,KAAK,UAAU,CAAC,KAAK,CAAC;AAAA;AAAA,EAGtB,KAAK,UAAU,CAAC,KAAK,CAAC;AACxB;;;ACjEA,eAAsB,sBAAsB,GAAY;AACtD,MAAI;AACF,UAAM,UAAU,WAAW;AAC3B,QAAI,CAAC,SAAS;AACZ,aAAO,EAAE,KAAK,EAAE,OAAO,2BAA2B,GAAG,GAAG;AAAA,IAC1D;AAEA,UAAM,mBAAmB,GAAG,OAAO;AAEnC,QAAI;AACF,YAAM,gBAAgB,MAAM,aAAa,gBAAgB;AACzD,YAAM,SAAS,KAAK,MAAM,aAAa;AAEvC,UAAI,OAAO,YAAY,OAAO,OAAO,aAAa,UAAU;AAC1D,cAAM,eAAe,OAAO,KAAK,OAAO,QAAQ;AAGhD,cAAM,WAA0B,CAAC;AACjC,mBAAW,QAAQ,cAAc;AAC/B,gBAAM,cAAc,MAAM,sBAAsB,IAAI;AAEpD,cAAI,aAAa;AACf,qBAAS,KAAK;AAAA,cACZ;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAEA,cAAM,WAA6B,EAAE,SAAS;AAC9C,eAAO,EAAE,KAAK,QAAQ;AAAA,MACxB,OAAO;AACL,cAAM,WAA6B,EAAE,UAAU,CAAC,EAAE;AAClD,eAAO,EAAE,KAAK,QAAQ;AAAA,MACxB;AAAA,IACF,SAAS,OAAO;AAEd,UAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,cAAc,GAAG;AACpE,cAAM,WAA6B,EAAE,UAAU,CAAC,EAAE;AAClD,eAAO,EAAE,KAAK,QAAQ;AAAA,MACxB;AACA,YAAM;AAAA,IACR;AAAA,EACF,SAAS,OAAO;AACd,WAAO,IAAI,MAAM,mCAAmC,EAAE,MAAM,CAAC;AAC7D,WAAO,EAAE,KAAK,EAAE,OAAO,0BAA0B,GAAG,GAAG;AAAA,EACzD;AACF;;;AChBA,eAAe,iBACb,UACkC;AAClC,MAAI;AACF,UAAM,UAAU,MAAM,aAAa,QAAQ;AAC3C,UAAM,QAAQ,QACX,KAAK,EACL,MAAM,IAAI,EACV,OAAO,CAAC,SAAS,KAAK,KAAK,CAAC;AAE/B,QAAI,MAAM,WAAW,GAAG;AACtB,aAAO;AAAA,IACT;AAEA,UAAM,WAA6B,CAAC;AACpC,UAAM,aAAa,oBAAI,IAAY;AACnC,QAAI,YAAY;AAChB,QAAI,WAAW;AACf,QAAI,qBAAqB;AAEzB,eAAW,QAAQ,OAAO;AACxB,UAAI;AACF,cAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,iBAAS,KAAK,MAAM;AAGpB,YAAI,OAAO,SAAS,SAAS,eAAe,OAAO,SAAS,IAAI;AAC9D,qBAAW,IAAI,OAAO,QAAQ,EAAE;AAAA,QAClC;AAGA,YAAI,CAAC,aAAa,OAAO,YAAY,WAAW;AAC9C,sBAAY,OAAO;AAAA,QACrB;AACA,YAAI,CAAC,YAAY,OAAO,YAAY,UAAU;AAC5C,qBAAW,OAAO;AAAA,QACpB;AAGA,YAAI,OAAO,SAAS,SAAS,eAAe,OAAO,SAAS,SAAS;AACnE,gBAAMC,WAAU,OAAO,QAAQ;AAC/B,cAAI,MAAM,QAAQA,QAAO,GAAG;AAE1B,uBAAW,QAAQA,UAAS;AAC1B,kBAAI,OAAO,SAAS,YAAY,QAAQ,UAAU,MAAM;AACtD,qCAAqB,OAAO,KAAK,IAAI,EAAE,UAAU,GAAG,GAAG;AACvD;AAAA,cACF;AAAA,YACF;AAAA,UACF,WAAW,OAAOA,aAAY,UAAU;AACtC,iCAAqBA,SAAQ,UAAU,GAAG,GAAG;AAAA,UAC/C;AAAA,QACF;AAAA,MACF,SAAS,YAAY;AACnB,eAAO,QAAQ,MAAM,2BAA2B,QAAQ,aAAa;AAAA,UACnE,OAAO;AAAA,QACT,CAAC;AAAA,MAEH;AAAA,IACF;AAGA,UAAM,WAAW,SAAS,MAAM,GAAG,EAAE,IAAI,KAAK;AAC9C,UAAM,YAAY,SAAS,QAAQ,UAAU,EAAE;AAE/C,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc,SAAS;AAAA,MACvB,oBAAoB,sBAAsB;AAAA,IAC5C;AAAA,EACF,SAAS,OAAO;AACd,WAAO,QAAQ,MAAM,+BAA+B,QAAQ,aAAa;AAAA,MACvE;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AACF;AAMA,eAAe,gBAAgB,YAAuC;AACpE,MAAI;AACF,UAAM,QAAkB,CAAC;AAEzB,qBAAiB,SAAS,QAAQ,UAAU,GAAG;AAC7C,UAAI,MAAM,UAAU,MAAM,KAAK,SAAS,QAAQ,GAAG;AACjD,cAAM,KAAK,GAAG,UAAU,IAAI,MAAM,IAAI,EAAE;AAAA,MAC1C;AAAA,IACF;AAEA,WAAO;AAAA,EACT,QAAQ;AAEN,WAAO,CAAC;AAAA,EACV;AACF;AAMA,eAAsB,qBACpB,YAC6B;AAC7B,QAAM,YAAY,MAAM,gBAAgB,UAAU;AAClD,QAAM,UAA8B,CAAC;AAErC,aAAW,YAAY,WAAW;AAChC,UAAM,SAAS,MAAM,iBAAiB,QAAQ;AAC9C,QAAI,QAAQ;AACV,cAAQ,KAAK,MAAM;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AACT;AAKO,SAAS,SAAY,QAAgB,UAA2B;AACrE,MAAI,OAAO,OAAO,SAAS,MAAM;AAC/B,WAAO;AAAA,EACT;AAEA,aAAW,QAAQ,QAAQ;AACzB,QAAI,CAAC,SAAS,IAAI,IAAI,GAAG;AACvB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;AC1KO,SAAS,mBACd,mBACuB;AACvB,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO,CAAC;AAAA,EACV;AAIA,QAAM,sBAAsB,CAAC,GAAG,iBAAiB,EAAE,KAAK,CAAC,GAAG,MAAM;AAChE,WAAO,EAAE,WAAW,OAAO,EAAE,WAAW;AAAA,EAC1C,CAAC;AAGD,QAAM,sBAA0C,CAAC;AAEjD,aAAW,eAAe,qBAAqB;AAE7C,UAAM,qBAAqB,oBAAoB;AAAA,MAAK,CAAC,iBACnD,SAAS,YAAY,YAAY,aAAa,UAAU;AAAA,IAC1D;AAEA,QAAI,CAAC,oBAAoB;AAEvB,0BAAoB,KAAK,WAAW;AAAA,IACtC;AAAA,EACF;AAGA,QAAM,YAAY,oBAAoB;AAAA,IAAI,CAAC,SACzC,0BAA0B,IAAI;AAAA,EAChC;AAGA,YAAU;AAAA,IACR,CAAC,GAAG,MAAM,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAAI,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,EAC5E;AAEA,SAAO;AACT;AAKA,SAAS,0BACP,kBACqB;AACrB,SAAO;AAAA,IACL,WAAW,iBAAiB;AAAA,IAC5B,WAAW,iBAAiB;AAAA,IAC5B,UAAU,iBAAiB;AAAA,IAC3B,cAAc,iBAAiB;AAAA,IAC/B,oBAAoB,iBAAiB;AAAA,EACvC;AACF;;;ACpDA,eAAsB,uBAAuB,GAAY;AACvD,MAAI;AACF,UAAM,qBAAqB,EAAE,IAAI,MAAM,oBAAoB;AAE3D,QAAI,CAAC,oBAAoB;AACvB,aAAO,EAAE,KAAK,EAAE,OAAO,mCAAmC,GAAG,GAAG;AAAA,IAClE;AAEA,QAAI,CAAC,2BAA2B,kBAAkB,GAAG;AACnD,aAAO,EAAE,KAAK,EAAE,OAAO,+BAA+B,GAAG,GAAG;AAAA,IAC9D;AAEA,WAAO,QAAQ;AAAA,MACb,2CAA2C,kBAAkB;AAAA,IAC/D;AAGA,UAAM,UAAU,WAAW;AAC3B,QAAI,CAAC,SAAS;AACZ,aAAO,EAAE,KAAK,EAAE,OAAO,2BAA2B,GAAG,GAAG;AAAA,IAC1D;AAGA,UAAM,aAAa,GAAG,OAAO,qBAAqB,kBAAkB;AAEpE,WAAO,QAAQ,MAAM,sBAAsB,UAAU,EAAE;AAGvD,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,UAAU;AACrC,UAAI,CAAC,QAAQ,aAAa;AACxB,eAAO,EAAE,KAAK,EAAE,OAAO,oBAAoB,GAAG,GAAG;AAAA,MACnD;AAAA,IACF,SAAS,OAAO;AAEd,UAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,cAAc,GAAG;AACpE,eAAO,EAAE,KAAK,EAAE,OAAO,oBAAoB,GAAG,GAAG;AAAA,MACnD;AACA,YAAM;AAAA,IACR;AAEA,UAAM,oBAAoB,MAAM,qBAAqB,UAAU;AAE/D,WAAO,QAAQ;AAAA,MACb,SAAS,kBAAkB,MAAM;AAAA,IACnC;AAGA,UAAM,gBAAgB,mBAAmB,iBAAiB;AAE1D,WAAO,QAAQ;AAAA,MACb,mBAAmB,cAAc,MAAM;AAAA,IACzC;AAEA,UAAM,WAAgC;AAAA,MACpC;AAAA,IACF;AAEA,WAAO,EAAE,KAAK,QAAQ;AAAA,EACxB,SAAS,OAAO;AACd,WAAO,QAAQ,MAAM,kDAAkD;AAAA,MACrE;AAAA,IACF,CAAC;AAED,WAAO,EAAE;AAAA,MACP;AAAA,QACE,OAAO;AAAA,QACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAChE;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;AC3EO,SAAS,kBACd,UACkB;AAElB,QAAM,eAAe,oBAAI,IAAoB;AAG7C,aAAW,OAAO,UAAU;AAC1B,QAAI,IAAI,SAAS,eAAe,IAAI,SAAS,IAAI;AAC/C,YAAM,YAAY,IAAI,QAAQ;AAC9B,UAAI,CAAC,aAAa,IAAI,SAAS,GAAG;AAChC,qBAAa,IAAI,WAAW,IAAI,SAAS;AAAA,MAC3C,OAAO;AAEL,cAAM,oBAAoB,aAAa,IAAI,SAAS;AACpD,YAAI,IAAI,YAAY,mBAAmB;AACrC,uBAAa,IAAI,WAAW,IAAI,SAAS;AAAA,QAC3C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,SAAO,SAAS,IAAI,CAAC,QAAQ;AAC3B,QAAI,IAAI,SAAS,eAAe,IAAI,SAAS,IAAI;AAC/C,YAAM,oBAAoB,aAAa,IAAI,IAAI,QAAQ,EAAE;AACzD,UAAI,mBAAmB;AACrB,eAAO;AAAA,UACL,GAAG;AAAA,UACH,WAAW;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAKO,SAAS,wBACd,UACkB;AAClB,SAAO,CAAC,GAAG,QAAQ,EAAE,KAAK,CAAC,GAAG,MAAM;AAClC,WAAO,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAAI,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,EACzE,CAAC;AACH;AAKO,SAAS,8BAA8B,UAI5C;AACA,MAAI,SAAS,WAAW,GAAG;AACzB,UAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AACnC,WAAO;AAAA,MACL,WAAW;AAAA,MACX,SAAS;AAAA,MACT,cAAc;AAAA,IAChB;AAAA,EACF;AAGA,QAAM,iBAAiB,wBAAwB,QAAQ;AACvD,QAAM,YAAY,eAAe,CAAC,EAAE;AACpC,QAAM,UAAU,eAAe,eAAe,SAAS,CAAC,EAAE;AAE1D,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,cAAc,SAAS;AAAA,EACzB;AACF;AAMO,SAAS,4BACd,UACA,YAQA;AAEA,QAAM,mBAAmB,kBAAkB,QAAQ;AAGnD,QAAM,iBAAiB,wBAAwB,gBAAgB;AAG/D,QAAM,WAAW,8BAA8B,cAAc;AAG7D,SAAO;AAAA,IACL,UAAU;AAAA,IACV;AAAA,EACF;AACF;;;ACvGA,eAAsB,iBACpB,oBACA,WACqC;AAErC,MAAI,CAAC,2BAA2B,kBAAkB,GAAG;AACnD,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAEA,MAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAGA,QAAM,UAAU,WAAW;AAC3B,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC5C;AAGA,QAAM,aAAa,GAAG,OAAO,qBAAqB,kBAAkB;AACpE,QAAM,WAAW,GAAG,UAAU,IAAI,SAAS;AAG3C,MAAI,CAAE,MAAM,OAAO,QAAQ,GAAI;AAC7B,WAAO;AAAA,EACT;AAEA,MAAI;AACF,UAAM,sBAAsB,MAAM;AAAA,MAChC;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM;AAAA,EACR;AACF;AAMA,eAAe,sBACb,UACA,WAC8B;AAC9B,QAAM,UAAU,MAAM,aAAa,QAAQ;AAC3C,QAAM,QAAQ,QACX,KAAK,EACL,MAAM,IAAI,EACV,OAAO,CAAC,SAAS,KAAK,KAAK,CAAC;AAE/B,MAAI,MAAM,WAAW,GAAG;AACtB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAEA,QAAM,WAA6B,CAAC;AAEpC,aAAW,QAAQ,OAAO;AACxB,QAAI;AACF,YAAM,SAAS,KAAK,MAAM,IAAI;AAC9B,eAAS,KAAK,MAAM;AAAA,IACtB,SAAS,YAAY;AACnB,aAAO,QAAQ,MAAM,2BAA2B,QAAQ,aAAa;AAAA,QACnE,OAAO;AAAA,MACT,CAAC;AAAA,IAEH;AAAA,EACF;AAGA,QAAM,EAAE,UAAU,mBAAmB,SAAS,IAAI;AAAA,IAChD;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA,UAAU;AAAA,IACV;AAAA,EACF;AACF;AAMA,SAAS,kBAAkB,WAA4B;AAErD,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAIA,QAAM,iBAAiB;AACvB,MAAI,eAAe,KAAK,SAAS,GAAG;AAClC,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,SAAS,KAAK;AAC1B,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,WAAW,GAAG,GAAG;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ACrHA,eAAsB,0BAA0B,GAAY;AAC1D,MAAI;AACF,UAAM,qBAAqB,EAAE,IAAI,MAAM,oBAAoB;AAC3D,UAAM,YAAY,EAAE,IAAI,MAAM,WAAW;AAEzC,QAAI,CAAC,oBAAoB;AACvB,aAAO,EAAE,KAAK,EAAE,OAAO,mCAAmC,GAAG,GAAG;AAAA,IAClE;AAEA,QAAI,CAAC,WAAW;AACd,aAAO,EAAE,KAAK,EAAE,OAAO,yBAAyB,GAAG,GAAG;AAAA,IACxD;AAEA,QAAI,CAAC,2BAA2B,kBAAkB,GAAG;AACnD,aAAO,EAAE,KAAK,EAAE,OAAO,+BAA+B,GAAG,GAAG;AAAA,IAC9D;AAEA,WAAO,QAAQ;AAAA,MACb,8CAA8C,kBAAkB,cAAc,SAAS;AAAA,IACzF;AAGA,UAAM,sBAAsB,MAAM;AAAA,MAChC;AAAA,MACA;AAAA,IACF;AAEA,QAAI,CAAC,qBAAqB;AACxB,aAAO,EAAE;AAAA,QACP;AAAA,UACE,OAAO;AAAA,UACP;AAAA,QACF;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO,QAAQ;AAAA,MACb,4BAA4B,oBAAoB,SAAS,MAAM;AAAA,IACjE;AAEA,WAAO,EAAE,KAAK,mBAAmB;AAAA,EACnC,SAAS,OAAO;AACd,WAAO,QAAQ,MAAM,gDAAgD;AAAA,MACnE;AAAA,IACF,CAAC;AAGD,QAAI,iBAAiB,OAAO;AAC1B,UAAI,MAAM,QAAQ,SAAS,oBAAoB,GAAG;AAChD,eAAO,EAAE;AAAA,UACP;AAAA,YACE,OAAO;AAAA,YACP,SAAS,MAAM;AAAA,UACjB;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,UAAI,MAAM,QAAQ,SAAS,8BAA8B,GAAG;AAC1D,eAAO,EAAE;AAAA,UACP;AAAA,YACE,OAAO;AAAA,YACP,SAAS,MAAM;AAAA,UACjB;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,EAAE;AAAA,MACP;AAAA,QACE,OAAO;AAAA,QACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAChE;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;ACxFA,SAAS,aAAkC;AAgB3C,gBAAgB,qBACd,SACA,WACA,yBACA,SACA,WACA,cACA,kBACA,gBACgC;AAChC,MAAI;AAEJ,MAAI;AAEF,QAAI,mBAAmB;AACvB,QAAI,QAAQ,WAAW,GAAG,GAAG;AAE3B,yBAAmB,QAAQ,UAAU,CAAC;AAAA,IACxC;AAGA,sBAAkB,IAAI,gBAAgB;AACtC,4BAAwB,IAAI,WAAW,eAAe;AAEtD,qBAAiB,cAAc,MAAM;AAAA,MACnC,QAAQ;AAAA,MACR,SAAS;AAAA,QACP;AAAA,QACA,YAAY;AAAA,QACZ,gBAAgB,CAAC;AAAA,QACjB,4BAA4B;AAAA,QAC5B,GAAI,YAAY,EAAE,QAAQ,UAAU,IAAI,CAAC;AAAA,QACzC,GAAI,eAAe,EAAE,aAAa,IAAI,CAAC;AAAA,QACvC,GAAI,mBAAmB,EAAE,KAAK,iBAAiB,IAAI,CAAC;AAAA,QACpD,GAAI,iBAAiB,EAAE,eAAe,IAAI,CAAC;AAAA,MAC7C;AAAA,IACF,CAAC,GAAG;AAEF,aAAO,KAAK,MAAM,oCAAoC,EAAE,WAAW,CAAC;AAEpE,YAAM;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IACF;AAEA,UAAM,EAAE,MAAM,OAAO;AAAA,EACvB,SAAS,OAAO;AAMd;AACE,aAAO,KAAK,MAAM,yCAAyC,EAAE,MAAM,CAAC;AACpE,YAAM;AAAA,QACJ,MAAM;AAAA,QACN,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D;AAAA,IACF;AAAA,EACF,UAAE;AAEA,QAAI,wBAAwB,IAAI,SAAS,GAAG;AAC1C,8BAAwB,OAAO,SAAS;AAAA,IAC1C;AAAA,EACF;AACF;AAQA,eAAsB,kBACpB,GACA,yBACA;AACA,QAAM,cAA2B,MAAM,EAAE,IAAI,KAAK;AAClD,QAAM,EAAE,QAAQ,IAAI,EAAE,IAAI;AAE1B,SAAO,KAAK;AAAA,IACV;AAAA,IACA;AAAA,EACF;AAEA,QAAM,SAAS,IAAI,eAAe;AAAA,IAChC,MAAM,MAAM,YAAY;AACtB,UAAI;AACF,yBAAiB,SAAS;AAAA,UACxB,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ;AAAA,UACA;AAAA;AAAA,UACA,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,YAAY;AAAA,QACd,GAAG;AACD,gBAAM,OAAO,KAAK,UAAU,KAAK,IAAI;AACrC,qBAAW,QAAQ,IAAI,YAAY,EAAE,OAAO,IAAI,CAAC;AAAA,QACnD;AACA,mBAAW,MAAM;AAAA,MACnB,SAAS,OAAO;AACd,cAAM,gBAAgC;AAAA,UACpC,MAAM;AAAA,UACN,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC9D;AACA,mBAAW;AAAA,UACT,IAAI,YAAY,EAAE,OAAO,KAAK,UAAU,aAAa,IAAI,IAAI;AAAA,QAC/D;AACA,mBAAW,MAAM;AAAA,MACnB;AAAA,IACF;AAAA,EACF,CAAC;AAED,SAAO,IAAI,SAAS,QAAQ;AAAA,IAC1B,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,YAAY;AAAA,IACd;AAAA,EACF,CAAC;AACH;;;AClIO,SAAS,mBACd,GACA,yBACA;AACA,QAAM,YAAY,EAAE,IAAI,MAAM,WAAW;AAEzC,MAAI,CAAC,WAAW;AACd,WAAO,EAAE,KAAK,EAAE,OAAO,yBAAyB,GAAG,GAAG;AAAA,EACxD;AAEA,SAAO,IAAI,MAAM,8BAA8B,SAAS,EAAE;AAC1D,SAAO,IAAI;AAAA,IACT,oBAAoB,MAAM,KAAK,wBAAwB,KAAK,CAAC,CAAC;AAAA,EAChE;AAEA,QAAM,kBAAkB,wBAAwB,IAAI,SAAS;AAC7D,MAAI,iBAAiB;AACnB,oBAAgB,MAAM;AACtB,4BAAwB,OAAO,SAAS;AAExC,WAAO,IAAI,MAAM,oBAAoB,SAAS,EAAE;AAEhD,WAAO,EAAE,KAAK,EAAE,SAAS,MAAM,SAAS,kBAAkB,CAAC;AAAA,EAC7D,OAAO;AACL,WAAO,EAAE,KAAK,EAAE,OAAO,yCAAyC,GAAG,GAAG;AAAA,EACxE;AACF;;;A3BRO,SAAS,UACdC,UACA,QACqB;AACrB,QAAM,MAAM,IAAI,KAAoB;AAGpC,QAAM,0BAA0B,oBAAI,IAA6B;AAGjE,MAAI;AAAA,IACF;AAAA,IACA,KAAK;AAAA,MACH,QAAQ;AAAA,MACR,cAAc,CAAC,OAAO,QAAQ,SAAS;AAAA,MACvC,cAAc,CAAC,cAAc;AAAA,IAC/B,CAAC;AAAA,EACH;AAGA,MAAI;AAAA,IACF;AAAA,IACA,uBAAuB;AAAA,MACrB,WAAW,OAAO;AAAA,MAClB,SAAAA;AAAA,MACA,SAAS,OAAO;AAAA,IAClB,CAAC;AAAA,EACH;AAGA,MAAI,IAAI,iBAAiB,CAAC,MAAM,sBAAsB,CAAC,CAAC;AAExD,MAAI;AAAA,IAAI;AAAA,IAA+C,CAAC,MACtD,uBAAuB,CAAC;AAAA,EAC1B;AAEA,MAAI;AAAA,IAAI;AAAA,IAA0D,CAAC,MACjE,0BAA0B,CAAC;AAAA,EAC7B;AAEA,MAAI;AAAA,IAAK;AAAA,IAAyB,CAAC,MACjC,mBAAmB,GAAG,uBAAuB;AAAA,EAC/C;AAEA,MAAI,KAAK,aAAa,CAAC,MAAM,kBAAkB,GAAG,uBAAuB,CAAC;AAI1E,QAAMC,eAAcD,SAAQ,2BAA2B;AAAA,IACrD,MAAM,OAAO;AAAA,EACf,CAAC;AACD,MAAI,IAAI,aAAaC,YAAW;AAGhC,MAAI,IAAI,KAAK,OAAO,MAAM;AACxB,UAAM,OAAO,EAAE,IAAI;AAGnB,QAAI,KAAK,WAAW,OAAO,GAAG;AAC5B,aAAO,EAAE,KAAK,aAAa,GAAG;AAAA,IAChC;AAEA,QAAI;AACF,YAAM,YAAY,GAAG,OAAO,UAAU;AACtC,YAAM,YAAY,MAAM,eAAe,SAAS;AAChD,aAAO,EAAE,KAAK,IAAI,YAAY,EAAE,OAAO,SAAS,CAAC;AAAA,IACnD,SAAS,OAAO;AACd,aAAO,IAAI,MAAM,qCAAqC,EAAE,MAAM,CAAC;AAC/D,aAAO,EAAE,KAAK,yBAAyB,GAAG;AAAA,IAC5C;AAAA,EACF,CAAC;AAED,SAAO;AACT;;;A4B/FA,SAAS,aAAgC;AACzC,OAAOC,cAAa;AACpB,SAAS,aAAa;AACtB,SAAS,QAAAC,aAAY;AAGrB,SAAS,mBAAmB;AAGrB,IAAM,cAAN,MAAqC;AAAA,EAC1C,MAAM,eAAe,MAAiC;AACpD,UAAM,WAAW,YAAY;AAC7B,UAAM,aAAuB,CAAC;AAE9B,QAAI,aAAa,WAAW;AAE1B,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA,GAAG,IAAI;AAAA,QACP,GAAG,IAAI;AAAA,QACP,GAAG,IAAI;AAAA,MACT;AAEA,iBAAW,YAAY,iBAAiB;AACtC,cAAM,SAAS,MAAM,KAAK,WAAW,SAAS,CAAC,QAAQ,CAAC;AACxD,YAAI,OAAO,WAAW,OAAO,OAAO,KAAK,GAAG;AAE1C,gBAAM,QAAQ,OAAO,OAClB,KAAK,EACL,MAAM,IAAI,EACV,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EACnB,OAAO,CAAC,MAAM,CAAC;AAClB,qBAAW,KAAK,GAAG,KAAK;AAAA,QAC1B;AAAA,MACF;AAAA,IACF,OAAO;AAEL,YAAM,SAAS,MAAM,KAAK,WAAW,SAAS,CAAC,IAAI,CAAC;AACpD,UAAI,OAAO,WAAW,OAAO,OAAO,KAAK,GAAG;AAC1C,mBAAW,KAAK,OAAO,OAAO,KAAK,CAAC;AAAA,MACtC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,WACE,SACA,MACA,SACwB;AACxB,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,YAAM,YAAY,YAAY,MAAM;AACpC,YAAM,eAA6B;AAAA,QACjC,OAAO,CAAC,UAAU,QAAQ,MAAM;AAAA,QAChC,KAAK,SAAS,MAAM,EAAE,GAAGC,SAAQ,KAAK,GAAG,QAAQ,IAAI,IAAIA,SAAQ;AAAA,MACnE;AAGA,UAAI,gBAAgB;AACpB,UAAI,aAAa;AAEjB,UAAI,WAAW;AACb,wBAAgB;AAChB,qBAAa,CAAC,MAAM,SAAS,GAAG,IAAI;AAAA,MACtC;AAEA,YAAM,QAAQ,MAAM,eAAe,YAAY,YAAY;AAE3D,YAAM,cAAc,IAAI,YAAY;AACpC,UAAI,SAAS;AACb,UAAI,SAAS;AAEb,YAAM,QAAQ,GAAG,QAAQ,CAAC,SAAqB;AAC7C,kBAAU,YAAY,OAAO,MAAM,EAAE,QAAQ,KAAK,CAAC;AAAA,MACrD,CAAC;AAED,YAAM,QAAQ,GAAG,QAAQ,CAAC,SAAqB;AAC7C,kBAAU,YAAY,OAAO,MAAM,EAAE,QAAQ,KAAK,CAAC;AAAA,MACrD,CAAC;AAED,YAAM,GAAG,SAAS,CAAC,SAAwB;AACzC,gBAAQ;AAAA,UACN,SAAS,SAAS;AAAA,UAClB,MAAM,QAAQ;AAAA,UACd;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAED,YAAM,GAAG,SAAS,CAAC,UAAiB;AAClC,gBAAQ;AAAA,UACN,SAAS;AAAA,UACT,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,QAAQ,MAAM;AAAA,QAChB,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MACE,MACA,UACA,SACM;AAEN,UAAM,MAAM,IAAIC,MAAK;AAGrB,QAAI,IAAI,KAAK,OAAO,MAAM;AACxB,YAAM,WAAW,MAAM,QAAQ,EAAE,IAAI,GAAG;AACxC,aAAO;AAAA,IACT,CAAC;AAGD,UAAM;AAAA,MACJ,OAAO,IAAI;AAAA,MACX;AAAA,MACA;AAAA,IACF,CAAC;AAED,YAAQ,IAAI,uBAAuB,QAAQ,IAAI,IAAI,GAAG;AAAA,EACxD;AAAA,EAEA,2BAA2B,SAA8C;AACvE,WAAO,YAAY,OAAO;AAAA,EAC5B;AACF;;;AChIA,SAAS,eAAe;;;ACJjB,IAAM,UAAU;;;ADehB,SAAS,eAA2B;AAEzC,QAAM,UAAU;AAGhB,QAAM,cAAc,SAAS,OAAO,MAAM,KAAK,QAAQ,EAAE;AAGzD,UACG,KAAK,mBAAmB,EACxB,QAAQ,SAAS,iBAAiB,wBAAwB,EAC1D,YAAY,mCAAmC,EAC/C;AAAA,IACC;AAAA,IACA;AAAA,IACA,CAAC,UAAU;AACT,YAAM,SAAS,SAAS,OAAO,EAAE;AACjC,UAAI,MAAM,MAAM,GAAG;AACjB,cAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;AAAA,MACjD;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF,EACC;AAAA,IACC;AAAA,IACA;AAAA,IACA;AAAA,EACF,EACC;AAAA,IACC;AAAA,IACA;AAAA,EACF,EACC,OAAO,eAAe,qBAAqB,KAAK;AAGnD,UAAQ,MAAM,QAAQ,GAAG,EAAE,MAAM,OAAO,CAAC;AACzC,QAAM,UAAU,QAAQ,KAAK;AAG7B,QAAM,WAAW,OAAO,OAAO;AAC/B,QAAM,eAAe,UAAU,YAAY,MAAM,UAAU,aAAa;AAExE,SAAO;AAAA,IACL,OAAO,QAAQ,SAAS;AAAA,IACxB,MAAM,QAAQ;AAAA,IACd,MAAM,QAAQ;AAAA,IACd,YAAY,QAAQ;AAAA,EACtB;AACF;;;AE5DA,SAAS,SAAS,QAAAC,aAAY;AAY9B,IAAM,yBAAyB;AAU/B,eAAe,eAAe,SAAyC;AACrE,MAAI;AACF,WAAO,IAAI,MAAM,gCAAgC,OAAO,EAAE;AAC1D,UAAM,aAAa,MAAM,aAAa,OAAO;AAG7C,UAAM,SAAS,QAAQ,OAAO;AAI9B,UAAM,gBAAgB,WAAW,MAAM,gCAAgC;AACvE,QAAI,eAAe;AACjB,YAAM,WAAW,cAAc,CAAC;AAEhC,YAAM,YAAY,SAAS,MAAM,aAAa;AAC9C,UAAI,WAAW;AACb,cAAM,eAAe,UAAU,CAAC;AAChC,cAAM,eAAeC,MAAK,QAAQ,YAAY;AAE9C,eAAO,IAAI,MAAM,+BAA+B,YAAY,EAAE;AAC9D,eAAO,IAAI,MAAM,2BAA2B,YAAY,EAAE;AAG1D,YAAI,MAAM,OAAO,YAAY,GAAG;AAC9B,iBAAO,IAAI,MAAM,4BAA4B,YAAY,EAAE;AAC3D,iBAAO;AAAA,QACT,OAAO;AACL,iBAAO,IAAI,MAAM,iCAAiC,YAAY,EAAE;AAAA,QAClE;AAAA,MACF,OAAO;AACL,eAAO,IAAI,MAAM,yCAAyC,QAAQ,EAAE;AAAA,MACtE;AAAA,IACF,OAAO;AACL,aAAO,IAAI,MAAM,uDAAuD;AAAA,IAC1E;AAEA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,WAAO,IAAI;AAAA,MACT,gCAAgC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,IACxF;AACA,WAAO;AAAA,EACT;AACF;AAQA,SAAS,wBAAwB,WAAmB,UAA0B;AAC5E,SAAO;AAAA,eAA2B,SAAS;AAAA,GAAO,QAAQ;AAC5D;AAQA,SAAS,qBAAqB,WAAmB,UAA0B;AACzE,SAAO;AAAA,gBAA8B,SAAS;AAAA,QAAY,QAAQ;AACpE;AASA,eAAsB,oBACpBC,UACA,YACwD;AACxD,QAAM,WAAW,YAAY;AAC7B,QAAM,YAAY,aAAa;AAG/B,MAAI,qBACF;AAEF,MAAI;AACF,yBAAqB,MAAM,YAAY,OAAO,YAAoB;AAChE,YAAM,YAAY,GAAG,OAAO;AAG5B,YAAM,kBAAkB,MAAMA,SAAQ,eAAe,MAAM;AAC3D,UAAI,gBAAgB,WAAW,GAAG;AAEhC,eAAO;AAAA,MACT;AAEA,YAAM,mBAAmB,gBAAgB,CAAC;AAG1C,YAAM,kBAAkB,YAAY,aAAa;AACjD,YAAM,gBAAgB,YAClB,wBAAwB,WAAW,gBAAgB,IACnD,qBAAqB,WAAW,gBAAgB;AAEpD,YAAM;AAAA,QACJ,GAAG,OAAO,IAAI,eAAe;AAAA,QAC7B;AAAA,QACA,YAAY,SAAY,EAAE,MAAM,IAAM;AAAA,MACxC;AAGA,YAAM,cAAc,OAAO,MAAM,KAAK;AACtC,YAAM,eAAe,YACjB,GAAG,OAAO,IAAI,WAAW,KACzB,GAAG,OAAO,IAAI,WAAW;AAE7B,YAAM,kBAAkB,MAAMA,SAAQ;AAAA,QACpC;AAAA,QACA,CAAC,WAAW;AAAA,QACZ;AAAA,UACE,KAAK,EAAE,MAAM,aAAa;AAAA,QAC5B;AAAA,MACF;AAGA,UAAI,CAAC,gBAAgB,SAAS;AAC5B,eAAO;AAAA,MACT;AAEA,YAAM,gBAAgB,gBAAgB,OAAO,KAAK;AAGlD,UAAI;AACJ,UAAI;AACF,uBAAe,MAAM,aAAa,SAAS;AAAA,MAC7C,QAAQ;AAEN,eAAO,EAAE,YAAY,IAAI,cAAc;AAAA,MACzC;AAEA,UAAI,CAAC,aAAa,KAAK,GAAG;AAExB,eAAO,EAAE,YAAY,IAAI,cAAc;AAAA,MACzC;AAEA,YAAM,aAAa,aAChB,MAAM,IAAI,EACV,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC,EACzB,OAAO,CAAC,SAAS,KAAK,SAAS,CAAC;AAGnC,iBAAW,aAAa,YAAY;AAClC,YAAI,aAAa,UAAU,KAAK;AAGhC,YAAI,YAAY;AAEd,cAAI,WAAW;AACb,yBAAa,WAAW,QAAQ,wBAAwB,IAAI;AAAA,UAC9D;AAAA,QACF;AAEA,YAAI,YAAY;AACd,iBAAO,EAAE,YAAY,cAAc;AAAA,QACrC;AAAA,MACF;AAGA,aAAO,EAAE,YAAY,IAAI,cAAc;AAAA,IACzC,CAAC;AAAA,EACH,SAAS,OAAO;AAEd,WAAO,IAAI;AAAA,MACT,mCAAmC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,IAC3F;AACA,yBAAqB;AAAA,EACvB;AAGA,MAAI,sBAAsB,mBAAmB,YAAY;AACvD,WAAO;AAAA,EACT;AAGA,MAAI,aAAa,WAAW,SAAS,MAAM,GAAG;AAC5C,WAAO,IAAI;AAAA,MACT;AAAA,IACF;AACA,QAAI;AACF,YAAM,gBAAgB,MAAM,eAAe,UAAU;AACrD,UAAI,eAAe;AAEjB,YAAI,gBAAgB,oBAAoB,iBAAiB;AACzD,YAAI,CAAC,eAAe;AAClB,cAAI;AACF,kBAAM,gBAAgB,MAAMA,SAAQ,WAAW,YAAY;AAAA,cACzD;AAAA,YACF,CAAC;AACD,gBAAI,cAAc,SAAS;AACzB,8BAAgB,cAAc,OAAO,KAAK;AAAA,YAC5C;AAAA,UACF,QAAQ;AAAA,UAER;AAAA,QACF;AACA,eAAO,EAAE,YAAY,eAAe,cAAc;AAAA,MACpD;AAAA,IACF,SAAS,eAAe;AACtB,aAAO,IAAI;AAAA,QACT,iCAAiC,yBAAyB,QAAQ,cAAc,UAAU,OAAO,aAAa,CAAC;AAAA,MACjH;AAAA,IACF;AAAA,EACF;AAGA,SAAO;AAAA,IACL,YAAY;AAAA,IACZ,eAAe,oBAAoB,iBAAiB;AAAA,EACtD;AACF;AAUA,eAAsB,kBACpBA,UACA,YACiB;AACjB,MAAI;AAEF,UAAM,WAAW,YAAY;AAC7B,UAAM,YAAY,aAAa;AAE/B,QAAI,aAAa;AAEjB,QAAI,YAAY;AAEd,mBAAa;AACb,aAAO,IAAI,KAAK,4CAAqC,UAAU,EAAE;AAAA,IACnE,OAAO;AAEL,aAAO,IAAI,KAAK,+CAAwC;AACxD,YAAM,aAAa,MAAMA,SAAQ,eAAe,QAAQ;AAExD,UAAI,WAAW,WAAW,GAAG;AAC3B,eAAO,IAAI,MAAM,qCAAgC;AACjD,eAAO,IAAI,MAAM,yCAAyC;AAC1D,eAAO,IAAI;AAAA,UACT;AAAA,QACF;AACA,aAAK,CAAC;AAAA,MACR;AAGA,UAAI,aAAa,WAAW,SAAS,GAAG;AACtC,cAAM,eAAe,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,MAAM,CAAC;AACpE,qBAAa,gBAAgB,WAAW,CAAC;AACzC,eAAO,IAAI;AAAA,UACT,gCAAgC,WAAW,KAAK,IAAI,CAAC;AAAA,QACvD;AACA,eAAO,IAAI;AAAA,UACT,0BAA0B,UAAU;AAAA,QACtC;AAAA,MACF,OAAO;AAEL,qBAAa,WAAW,CAAC;AACzB,eAAO,IAAI;AAAA,UACT,gCAAgC,WAAW,KAAK,IAAI,CAAC;AAAA,QACvD;AACA,eAAO,IAAI,MAAM,0BAA0B,UAAU,EAAE;AAAA,MACzD;AAAA,IACF;AAGA,UAAM,YAAY,WAAW,SAAS,MAAM;AAE5C,QAAI,aAAa,WAAW;AAC1B,aAAO,IAAI;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAGA,WAAO,IAAI,KAAK,sDAA+C;AAC/D,UAAM,YAAY,MAAM,oBAAoBA,UAAS,UAAU;AAE/D,QAAI,UAAU,YAAY;AACxB,aAAO,IAAI,KAAK,sCAAiC,UAAU,UAAU,EAAE;AACvE,UAAI,UAAU,eAAe;AAC3B,eAAO,IAAI,KAAK,4BAAuB,UAAU,aAAa,EAAE;AAAA,MAClE;AACA,aAAO,UAAU;AAAA,IACnB,OAAO;AAEL,aAAO,IAAI,KAAK,uDAA6C;AAC7D,aAAO,IAAI;AAAA,QACT;AAAA,MACF;AACA,aAAO,IAAI,KAAK,uDAAuD;AACvE,aAAO,IAAI,KAAK,EAAE;AAClB,aAAO,IAAI,KAAK,2BAA2B,UAAU,EAAE;AACvD,UAAI,UAAU,eAAe;AAC3B,eAAO,IAAI,KAAK,4BAAuB,UAAU,aAAa,EAAE;AAAA,MAClE;AACA,aAAO;AAAA,IACT;AAAA,EACF,SAAS,OAAO;AACd,WAAO,IAAI,MAAM,sCAAiC;AAClD,WAAO,IAAI;AAAA,MACT,aAAa,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,IACrE;AACA,SAAK,CAAC;AAAA,EACR;AACF;;;AC3UA,SAAS,qBAAqB;AAC9B,SAAS,WAAAC,UAAS,QAAAC,aAAY;AAG9B,eAAe,KAAKC,UAAsB;AAExC,QAAM,OAAO,aAAa;AAG1B,QAAM,YAAY,KAAK,KAAK;AAE5B,MAAI,KAAK,OAAO;AACd,WAAO,IAAI,KAAK,8BAAuB;AAAA,EACzC;AAGA,QAAM,UAAU,MAAM,kBAAkBA,UAAS,KAAK,UAAU;AAIhE,QAAM,YACJ,YAAY,WAAWC,SAAQ,cAAc,YAAY,GAAG,CAAC;AAC/D,QAAM,aAAaC,MAAK,WAAW,WAAW;AAG9C,QAAM,MAAM,UAAUF,UAAS;AAAA,IAC7B,WAAW,KAAK;AAAA,IAChB;AAAA,IACA;AAAA,EACF,CAAC;AAGD,SAAO,IAAI,KAAK,gCAAyB,KAAK,IAAI,IAAI,KAAK,IAAI,EAAE;AACjE,EAAAA,SAAQ,MAAM,KAAK,MAAM,KAAK,MAAM,IAAI,KAAK;AAC/C;AAGA,IAAM,UAAU,IAAI,YAAY;AAChC,KAAK,OAAO,EAAE,MAAM,CAAC,UAAU;AAE7B,UAAQ,MAAM,2BAA2B,KAAK;AAC9C,OAAK,CAAC;AACR,CAAC;",
  "names": ["process", "filter: FilterLike", "level: LogLevel | null", "record: LogRecord", "a: LogLevel", "b: LogLevel", "category: string | readonly string[]", "LoggerImpl", "rootLogger: LoggerImpl | null", "parent: LoggerImpl | null", "category: readonly string[]", "subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])]", "child: LoggerImpl | undefined", "logger", "properties: Record<string, unknown>", "record: LogRecord", "level: LogLevel", "record: Omit<LogRecord, \"category\"> | LogRecord", "bypassSinks?: Set<Sink>", "fullRecord: LogRecord", "rawMessage: string", "properties: Record<string, unknown> | (() => Record<string, unknown>)", "cachedProps: Record<string, unknown> | undefined", "callback: LogCallback", "rawMessage: TemplateStringsArray | undefined", "msg: unknown[] | undefined", "messageTemplate: TemplateStringsArray", "values: unknown[]", "message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>", "LoggerCtx", "logger: LoggerImpl", "subcategory: string | readonly [string] | readonly [string, ...string[]]", "message: string", "record: Omit<LogRecord, \"category\">", "template: string", "message: unknown[]", "prop: unknown", "template: TemplateStringsArray", "values: readonly unknown[]", "obj: unknown", "options?: InspectOptions", "levelAbbreviations: Record<LogLevel, string>", "inspect: (value: unknown, options?: { colors?: boolean }) => string", "num: number", "ts: number", "options: TextFormatterOptions", "inspect", "level: LogLevel", "formatter: (values: FormattedValues) => string", "record: LogRecord", "message: string", "parts: string[]", "values: FormattedValues", "defaultTextFormatter: TextFormatter", "ansiColors: Record<AnsiColor, string>", "ansiStyles: Record<AnsiStyle, string>", "defaultLevelColors: Record<LogLevel, AnsiColor | null>", "options: AnsiColorFormatterOptions", "value: unknown", "ansiColorFormatter: TextFormatter", "options: JsonLinesFormatterOptions", "joinCategory: (category: readonly string[]) => string | readonly string[]", "category: readonly string[]", "getProperties: (\n    properties: Record<string, unknown>,\n  ) => Record<string, unknown>", "result: Record<string, unknown>", "getMessage: (record: LogRecord) => string", "jsonLinesFormatter: TextFormatter", "logLevelStyles: Record<LogLevel, string>", "values: unknown[]", "options: ConsoleSinkOptions", "levelMap: Record<LogLevel, ConsoleMethod>", "console", "record: LogRecord", "buffer: LogRecord[]", "flushTimer: ReturnType<typeof setInterval> | null", "nonBlockingSink: Sink & Disposable", "currentConfig: Config<string, string> | null", "strongRefs: Set<LoggerImpl>", "disposables: Set<Disposable>", "asyncDisposables: Set<AsyncDisposable>", "cfg: LoggerConfig<TSinkId, TFilterId>", "config: Config<TSinkId, TFilterId>", "config: Config<TSinkId, TFilterId>", "allowAsync: boolean", "logger", "promises: PromiseLike<void>[]", "message: string", "defaultWidth: number", "category: readonly string[]", "maxWidth: number", "separator: string", "strategy: TruncationStrategy", "text: string", "code: number", "ZERO_WIDTH_RANGES: Array<[number, number]>", "ranges: Array<[number, number]>", "text: string", "maxWidth: number", "messageContent: string", "wrappedLines: string[]", "indent: string", "lines: string[]", "inspect", "obj: unknown", "options?: InspectOptions", "util", "RESET", "ansiColors", "color: Color", "style: Style", "categoryColorMap: CategoryColorMap", "patterns: CategoryPattern[]", "category: readonly string[]", "prefix: readonly string[]", "defaultIcons: Record<LogLevel, string>", "iconMap: Record<LogLevel, string>", "options: PrettyFormatterOptions", "baseIconMap: Record<LogLevel, string>", "resolvedLevelColors: Record<LogLevel, Color>", "levelMappings: Record<string, Record<LogLevel, string>>", "level: LogLevel", "timestampFormatters: Record<string, (ts: number) => string>", "timestampFn: ((ts: number) => string | null) | null", "timestampFormatters", "wordWrapWidth: number", "allLevels: LogLevel[]", "record: LogRecord", "inspect", "prettyFormatter: TextFormatter", "content", "runtime", "serveStatic", "process", "Hono", "process", "Hono", "join", "join", "runtime", "dirname", "join", "runtime", "dirname", "join"]
}
